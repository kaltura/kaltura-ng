import { __decorate, __metadata, __extends, __spread } from 'tslib';
import { Renderer2, ViewChild, ElementRef, Input, Component, ViewEncapsulation, NgModule, EventEmitter, Output, ContentChildren, QueryList, HostListener, Directive, Injectable, TemplateRef, ContentChild, HostBinding, ViewChildren, Pipe } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormControl, FormGroup, FormBuilder, Validators, ReactiveFormsModule, NG_VALUE_ACCESSOR } from '@angular/forms';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import 'rxjs/add/observable/fromEvent';
import { cancelOnDestroy, KalturaCommonModule, EmptyLogger } from '@kaltura-ng/kaltura-common';
import { Subject } from 'rxjs/Subject';
import * as $NS from 'jquery';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/forkJoin';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/share';
import 'rxjs/add/operator/map';
import { ReplaySubject } from 'rxjs/ReplaySubject';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/do';
import * as momentNS from 'moment';
import { DomSanitizer } from '@angular/platform-browser';

var AreaBlockerMessage = /** @class */ (function () {
    function AreaBlockerMessage(content) {
        this.title = content.title || 'Error';
        this.message = content.message;
        this.buttons = content.buttons;
    }
    return AreaBlockerMessage;
}());

var AreaBlockerComponent = /** @class */ (function () {
    function AreaBlockerComponent(_renderer) {
        this._renderer = _renderer;
        this.bodyScroll = false;
        this.spinnerMarginTop = 0;
    }
    Object.defineProperty(AreaBlockerComponent.prototype, "showLoader", {
        get: function () {
            return this._showLoader;
        },
        set: function (value) {
            var _this = this;
            // once showLoader is set to true, use a timeout so *ngIf will cause the HTML to render and then calculate area blocker width
            if (value) {
                this._showLoaderHandler = setTimeout(function () {
                    _this._showLoaderHandler = null;
                    if (_this.bodyScroll && !!_this.areaBlockerContainer) {
                        var rect = _this.areaBlockerContainer.nativeElement.getBoundingClientRect();
                        if (rect.width < document.body.clientWidth && _this.spinnerContainer) {
                            _this._renderer.setStyle(_this.spinnerContainer.nativeElement, 'left', rect.left + rect.width / 2 + "px");
                        }
                    }
                    _this._renderer.setStyle(_this.spinnerContainer.nativeElement, 'opacity', '1'); // show the spinner only after its position is calculated to prevent seeing it jumps...
                }, 0);
            }
            else {
                if (this._showLoaderHandler) {
                    clearTimeout(this._showLoaderHandler);
                    this._showLoaderHandler = null;
                }
                if (this.bodyScroll && this.spinnerContainer) {
                    this._renderer.setStyle(this.spinnerContainer.nativeElement, 'opacity', '0'); // hide the spinner so we won't see it jump next time its position is recalculated
                }
            }
            this._showLoader = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AreaBlockerComponent.prototype, "message", {
        set: function (value) {
            var _this = this;
            if (typeof value === 'string') {
                this._message = { title: 'Error', message: value, buttons: [{ label: 'Dismiss', action: function () { _this._message = null; } }] };
            }
            else if (value instanceof AreaBlockerMessage) {
                this._message = value;
            }
            else {
                this._message = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    AreaBlockerComponent.prototype.handleAction = function (button) {
        if (button) {
            button.action();
        }
    };
    AreaBlockerComponent.prototype.ngOnInit = function () {
    };
    AreaBlockerComponent.ctorParameters = function () { return [
        { type: Renderer2 }
    ]; };
    __decorate([
        ViewChild('areaBlockerContainer', { static: false }),
        __metadata("design:type", ElementRef)
    ], AreaBlockerComponent.prototype, "areaBlockerContainer", void 0);
    __decorate([
        ViewChild('spinnerContainer', { static: false }),
        __metadata("design:type", ElementRef)
    ], AreaBlockerComponent.prototype, "spinnerContainer", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaBlockerComponent.prototype, "bodyScroll", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaBlockerComponent.prototype, "spinnerMarginTop", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaBlockerComponent.prototype, "classes", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], AreaBlockerComponent.prototype, "showLoader", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], AreaBlockerComponent.prototype, "message", null);
    AreaBlockerComponent = __decorate([
        Component({
            selector: 'k-area-blocker',
            template: "<ng-content></ng-content>\n<div #areaBlockerContainer *ngIf=\"showLoader || _message\" class=\"kAreaBlockerContainer\" [class.kAreaBlockerContainerError]=\"_message\" [ngClass]=\"classes\">\n  <div *ngIf=\"showLoader && !_message\" class=\"loading-backdrop show\">\n    <div #spinnerContainer class='spinner-container' [class.bodyScroll]=\"bodyScroll\" [style.marginTop]=\"spinnerMarginTop+'px'\">\n      <div class='spinner'><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></div>\n    </div>\n  </div>\n  <div  class=\"kErrorMessageContainer\" *ngIf=\"_message\" [class.bodyScroll]=\"bodyScroll\">\n    <div class=\"kErrorMessage\">\n      <div class=\"kErrorMessageTitle\">{{ _message.title }}</div>\n      <div class=\"kErrorMessageText\">{{ _message.message }}</div>\n      <div class=\"kErrorButtons\">\n        <button *ngFor=\"let button of _message.buttons\" (click)=\"handleAction(button)\" [ngClass]=\"button.classes\">{{button.label}}</button>\n      </div>\n    </div>\n  </div>\n</div>\n",
            encapsulation: ViewEncapsulation.None,
            styles: ["k-area-blocker{position:relative;width:100%;height:100%;display:flex;flex:1 1 auto}k-area-blocker>.kAreaBlockerContainer{display:flex;flex-direction:row;align-items:center;justify-content:center;width:100%;height:100%;background-color:rgba(255,255,255,.7);position:absolute;top:0;left:0;z-index:510}@-webkit-keyframes kaltura-spinner{0%{transform:rotate(0) scale(.7);opacity:1}100%,70%{transform:rotate(360deg) scale(.7);opacity:1}82%{transform:rotate(360deg) scale(0);opacity:0}87%{transform:rotate(360deg) scale(.9);opacity:1}}@keyframes kaltura-spinner{0%{transform:rotate(0) scale(.7);opacity:1}100%,70%{transform:rotate(360deg) scale(.7);opacity:1}82%{transform:rotate(360deg) scale(0);opacity:0}87%{transform:rotate(360deg) scale(.9);opacity:1}}k-area-blocker>.kAreaBlockerContainer .loading-backdrop{position:absolute;top:0;left:0;width:100%;height:100%}k-area-blocker>.kAreaBlockerContainer .loading-backdrop .spinner-container{display:block;opacity:0;transform:translate3d(-50px,-50px,0)}k-area-blocker>.kAreaBlockerContainer .loading-backdrop .spinner-container.bodyScroll{position:fixed}k-area-blocker>.kAreaBlockerContainer .spinner{width:100px;height:100px;position:relative;-webkit-animation:2.5s infinite kaltura-spinner;animation:2.5s infinite kaltura-spinner}k-area-blocker>.kAreaBlockerContainer .spinner span{width:8px;height:8px;background-color:#fff;display:block;border-radius:8px;position:absolute;top:50%;left:50%;margin-top:-4px;margin-left:-4px}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(1){transform:rotate(45deg) translateX(-25px) translateY(-25px);background-color:#da1f26}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(2){transform:rotate(90deg) translateX(-25px) translateY(-25px);background-color:#06a885}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(3){transform:rotate(135deg) translateX(-25px) translateY(-25px);background-color:#009344}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(4){transform:rotate(180deg) translateX(-25px) translateY(-25px);background-color:#f8a61a}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(5){transform:rotate(225deg) translateX(-25px) translateY(-25px);background-color:#1b4a97}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(6){transform:rotate(270deg) translateX(-25px) translateY(-25px);background-color:#00abcc}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(7){transform:rotate(315deg) translateX(-25px) translateY(-25px);background-color:#b1d238}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(8){transform:rotate(360deg) translateX(-25px) translateY(-25px);background-color:#fcd203}k-area-blocker>.kAreaBlockerContainer .kErrorMessageContainer{display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:1001}k-area-blocker>.kAreaBlockerContainer .kErrorMessageContainer.bodyScroll{margin-top:0;position:fixed;top:calc(50vh - 90px);left:calc(50vw - 293px)}k-area-blocker>.kAreaBlockerContainer .kErrorMessage{width:586px;background-color:#fff;border-radius:4px;box-shadow:0 16px 20px 0 rgba(0,0,0,.3);padding:60px 32px 32px;box-sizing:border-box;text-align:center}k-area-blocker>.kAreaBlockerContainer .kErrorMessageTitle{color:#333;font-size:20px;font-weight:700;line-height:24px}k-area-blocker>.kAreaBlockerContainer .kErrorMessageText{max-height:250px;min-height:30px;padding:4px;overflow-y:auto;color:#999;font-size:15px;font-weight:700;line-height:18px;margin-top:26px;white-space:pre-wrap}k-area-blocker>.kAreaBlockerContainer .kErrorButtons{margin-top:44px}k-area-blocker>.kAreaBlockerContainer .kErrorButtons button{cursor:pointer;min-width:100px;outline:0;color:#333;font-size:14px;font-weight:700;line-height:17px;text-align:center;height:34px;border:1px solid #ccc;border-radius:3px;background-color:#fff;box-sizing:border-box;padding:0 12px;margin:0 8px}"]
        }),
        __metadata("design:paramtypes", [Renderer2])
    ], AreaBlockerComponent);
    return AreaBlockerComponent;
}());

var AreaBlockerModule = /** @class */ (function () {
    function AreaBlockerModule() {
    }
    AreaBlockerModule = __decorate([
        NgModule({
            imports: [
                CommonModule
            ],
            declarations: [
                AreaBlockerComponent
            ],
            exports: [
                AreaBlockerComponent
            ],
            providers: []
        })
    ], AreaBlockerModule);
    return AreaBlockerModule;
}());

var DetailInfoComponent = /** @class */ (function () {
    function DetailInfoComponent() {
        this.toolTipAsHTML = true;
        this.separator = "|";
        this.maxItemWidth = 300;
        this.isLastItem = false;
        this.itemClick = new EventEmitter();
        this.isClickable = false;
    }
    DetailInfoComponent.prototype._setData = function (data) {
        this._data = data;
    };
    DetailInfoComponent.prototype.ngOnInit = function () {
        this.isClickable = this.itemClick.observers.length > 0;
    };
    DetailInfoComponent.prototype.onClick = function ($event) {
        if (this.isClickable) {
            this.itemClick.emit($event);
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DetailInfoComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DetailInfoComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DetailInfoComponent.prototype, "valueField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DetailInfoComponent.prototype, "link", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DetailInfoComponent.prototype, "tooltip", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DetailInfoComponent.prototype, "toolTipAsHTML", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DetailInfoComponent.prototype, "iconStyle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DetailInfoComponent.prototype, "separator", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], DetailInfoComponent.prototype, "maxItemWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DetailInfoComponent.prototype, "isLastItem", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], DetailInfoComponent.prototype, "itemClick", void 0);
    DetailInfoComponent = __decorate([
        Component({
            selector: 'kDetailInfo',
            template: "<div class=\"kDetailInfo\" *ngIf=\"_data\">\n    <div class=\"kDetails\" [style.maxWidth]=\"maxItemWidth+'px'\">\n        <div *ngIf=\"iconStyle\" [kTooltip]=\"tooltip\" class=\"{{iconStyle}} kIcon\"></div>\n        <span class=\"kLabel\" *ngIf=\"label\">{{label}}</span>\n        <span *ngIf=\"!link && (value || valueField)\" [kTooltip]=\"tooltip\" [escape]=\"toolTipAsHTML\" [class.link]=\"isClickable\" (click)=\"onClick($event)\">{{value || _data[valueField]}}</span>\n        <a *ngIf=\"link\" [href]=\"link\" [target]=\"'_blank'\" [kTooltip]=\"tooltip\" class=\"link\">{{link}}</a>\n    </div>\n    <div *ngIf=!isLastItem class=\"kSeparator\">{{separator}}</div>\n</div> ",
            styles: [".kDetailInfo{display:flex;line-height:26px;height:26px}.kDetailInfo .kDetails{display:flex;overflow:hidden}.kDetailInfo .kDetails>a,.kDetailInfo .kDetails>div,.kDetailInfo .kDetails>span{flex:0 0 auto;line-height:26px}.kDetailInfo .kSeparator{padding-right:8px;padding-left:8px;flex:0 0 auto;color:#ccc}.kDetailInfo .kIcon{font-size:16px}.kDetailInfo .kLabel{margin-right:4px}.kDetailInfo .link{font-size:15px;color:#1b4a97;text-decoration:underline;cursor:pointer;text-overflow:ellipsis}.kDetailInfo .link:hover{color:#13356c}.kDetailInfo .link:active{color:#1b4a97}.kDetailInfo .link:disabled{cursor:none;color:#ccc}"]
        }),
        __metadata("design:paramtypes", [])
    ], DetailInfoComponent);
    return DetailInfoComponent;
}());

var DetailsBarComponent = /** @class */ (function () {
    function DetailsBarComponent() {
        this.basicDetailsLabel = "Basic Details";
        this.moreDetailsLabel = "More Details";
        this._shouldUpdateItems = false;
        this._showMore = false;
        this._showBasic = false;
        this.lineScroll = 0;
        this.disableScroll = false;
    }
    Object.defineProperty(DetailsBarComponent.prototype, "data", {
        set: function (dataObj) {
            this._data = dataObj;
            this._shouldUpdateItems = true;
            this.reset();
        },
        enumerable: true,
        configurable: true
    });
    DetailsBarComponent.prototype.onWindowResize = function () {
        this.reset();
    };
    DetailsBarComponent.prototype.ngAfterViewChecked = function () {
        var _this = this;
        if (this._shouldUpdateItems) {
            this._shouldUpdateItems = false;
            setTimeout(function () {
                _this.items.forEach(function (item) {
                    item._setData(_this._data);
                });
            }, 0);
        }
    };
    DetailsBarComponent.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.updateLayout();
        this._itemsChangesSubscription = this.items.changes.subscribe(function (changes) {
            _this._shouldUpdateItems = true;
        });
    };
    DetailsBarComponent.prototype._updateItems = function () {
        var _this = this;
        if (this.items) {
            this.items.forEach(function (item) { return item._setData(_this._data); });
        }
    };
    DetailsBarComponent.prototype.updateLayout = function () {
        var _this = this;
        //we use a cancelable interval to improve performances on window resize
        if (this.showMoreCheckIntervalID) {
            clearInterval(this.showMoreCheckIntervalID);
            this.showMoreCheckIntervalID = null;
        }
        this.showMoreCheckIntervalID = setTimeout(function () {
            _this.items.forEach(function (item) {
                item.isLastItem = false;
            });
            _this.items.last.isLastItem = true;
            var marginTop = parseInt(window.getComputedStyle(_this.dataWrapper.nativeElement).top);
            var elementHeight = _this.dataWrapper.nativeElement.children.length ? _this.dataWrapper.nativeElement.children[0].clientHeight : 0;
            _this._showMore = _this.dataWrapper.nativeElement.clientHeight > _this.dataPanel.nativeElement.getBoundingClientRect().height && Math.abs(marginTop) < (_this.dataWrapper.nativeElement.clientHeight + marginTop);
            _this._showBasic = _this.dataWrapper.nativeElement.clientHeight > _this.dataPanel.nativeElement.getBoundingClientRect().height && marginTop < 0;
            // code to remove last separators in each line
            var topArr = [];
            if (_this.dataWrapper.nativeElement.children.length) {
                for (var i = 0; i < _this.dataWrapper.nativeElement.children.length; i++) {
                    var elm = _this.dataWrapper.nativeElement.children[i];
                    var top_1 = elm.getBoundingClientRect().top;
                    topArr.push(top_1);
                }
                var _loop_1 = function (i) {
                    if (topArr[i] < topArr[i + 1] && _this.items.length >= i) {
                        _this.items.forEach(function (item, index) {
                            if (i === index) {
                                item.isLastItem = true;
                            }
                        });
                    }
                };
                for (var i = 0; i < topArr.length - 1; i++) {
                    _loop_1(i);
                }
            }
            _this.showMoreCheckIntervalID = null;
        }, 100);
    };
    DetailsBarComponent.prototype.show = function (direction) {
        var _this = this;
        if (!this.disableScroll) {
            this.disableScroll = true;
            if (direction === "more") {
                this.lineScroll++;
            }
            else {
                this.lineScroll--;
            }
            this.dataWrapper.nativeElement.style.top = this.dataWrapper.nativeElement.children[0].clientHeight * (-1) * this.lineScroll + "px";
            setTimeout(function () {
                _this.updateLayout(); // allow animation to finish before recalculating
                _this.disableScroll = false;
            }, 350);
        }
    };
    DetailsBarComponent.prototype.reset = function () {
        var _this = this;
        this.lineScroll = 0;
        this.dataWrapper.nativeElement.style.top = "0px";
        setTimeout(function () {
            _this.updateLayout(); // allow animation to finish before recalculating
        }, 350);
    };
    DetailsBarComponent.prototype.ngOnDestroy = function () {
        if (this._itemsChangesSubscription) {
            this._itemsChangesSubscription.unsubscribe();
            this._itemsChangesSubscription = null;
        }
    };
    __decorate([
        ContentChildren(DetailInfoComponent),
        __metadata("design:type", QueryList)
    ], DetailsBarComponent.prototype, "items", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DetailsBarComponent.prototype, "basicDetailsLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DetailsBarComponent.prototype, "moreDetailsLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], DetailsBarComponent.prototype, "data", null);
    __decorate([
        ViewChild('dataPanel', { static: true }),
        __metadata("design:type", ElementRef)
    ], DetailsBarComponent.prototype, "dataPanel", void 0);
    __decorate([
        ViewChild('dataWrapper', { static: true }),
        __metadata("design:type", ElementRef)
    ], DetailsBarComponent.prototype, "dataWrapper", void 0);
    __decorate([
        HostListener("window:resize", []),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], DetailsBarComponent.prototype, "onWindowResize", null);
    DetailsBarComponent = __decorate([
        Component({
            selector: 'k-details-bar',
            template: "<div class=\"kContent kDetailsBar\" #dataPanel>\n    <i class=\"kLink kIcondropdown_arrow_bottom\" [class.disabled]=\"!_showMore\" [class.hidden]=\"!_showMore && !_showBasic\" (click)=\"show('more')\"></i>\n    <i class=\"kLink kIcondropdown_arrow_top\" [class.disabled]=\"!_showBasic\" [class.hidden]=\"!_showMore && !_showBasic\" (click)=\"show('basic')\"></i>\n    <div class=\"kItemsWrapper\" #dataWrapper>\n        <ng-content *ngIf=\"_data\" ></ng-content>\n    </div>\n</div>",
            styles: [".kDetailsBar{display:block;height:26px;line-height:26px;overflow-y:hidden;font-size:14px;color:#666}.kDetailsBar .kLink{font-size:14px;float:right;margin-left:8px;border:0;cursor:pointer;margin-top:5px}.kDetailsBar .kLink.disabled{opacity:.4;pointer-events:none}.kDetailsBar .kLink.hidden{opacity:0;pointer-events:none}.kDetailsBar .kItemsWrapper{position:relative;flex:1 1 auto;height:auto;display:flex;flex-flow:wrap;transition:top .3s}"]
        }),
        __metadata("design:paramtypes", [])
    ], DetailsBarComponent);
    return DetailsBarComponent;
}());

var KTooltipDirective = /** @class */ (function () {
    function KTooltipDirective(elementRef) {
        this.elementRef = elementRef;
        this._tooltipElement = null;
        this._tooltipContent = null;
        this._shouldBeVisible = false;
        this._tooltipHeight = null;
        this._tooltipWidth = null;
        this.tooltipResolver = null;
        this.escape = true;
        this.tooltipOffset = 8;
        this.placement = "top";
        this.delay = 300;
        this.maxWidth = 300;
        this.followTarget = false;
        this.showOnEllipsis = false;
    }
    Object.defineProperty(KTooltipDirective.prototype, "kTooltip", {
        set: function (value) {
            if (this.isValidContent(value)) {
                this._tooltipContent = value;
            }
            else {
                this._tooltipContent = null;
            }
            this._updateTooltipElement();
        },
        enumerable: true,
        configurable: true
    });
    KTooltipDirective.prototype.isValidContent = function (value) {
        return typeof value !== 'undefined' && value !== '' && value !== null;
    };
    KTooltipDirective.prototype._updateTooltipElement = function () {
        var _this = this;
        if (!this._tooltipContent) {
            if (this._isShowingTooltip()) {
                this._removeTooltipElement();
            }
        }
        else if (this._shouldBeVisible) {
            if (!this._isShowingTooltip()) {
                this._tooltipElement = document.createElement('span');
                this._tooltipElement.style.pointerEvents = 'none';
                this._tooltipElement.className += "ng-tooltip ng-tooltip-" + this.placement;
                if (this.maxWidth > 0) {
                    this._tooltipElement.style.maxWidth = this.maxWidth + "px";
                }
                var addTooltipVisibleClass = function () {
                    if (_this._tooltipElement) {
                        _this._tooltipElement.className += " ng-tooltip-show";
                    }
                };
                if (this.delay) {
                    setTimeout(addTooltipVisibleClass, this.delay);
                }
                else {
                    addTooltipVisibleClass();
                }
                document.body.appendChild(this._tooltipElement);
                if (this._updateTooltipElementContent()) {
                    this._updateTooltipElementPosition();
                }
            }
            else {
                if (this._updateTooltipElementContent()) {
                    this._updateTooltipElementPosition();
                }
            }
        }
        else {
            if (this._isShowingTooltip()) {
                this._removeTooltipElement();
            }
        }
    };
    KTooltipDirective.prototype.onMouseMove = function () {
        if (this.followTarget) {
            this._updateTooltipElementPosition();
        }
    };
    KTooltipDirective.prototype.onMouseEnter = function () {
        if (!this.showOnEllipsis || this.isInEllipsis()) {
            this._shouldBeVisible = true;
            this._updateTooltipElement();
        }
    };
    KTooltipDirective.prototype.onMouseLeave = function () {
        this._shouldBeVisible = false;
        this._updateTooltipElement();
    };
    KTooltipDirective.prototype.isInEllipsis = function () {
        // added the -1 threshold to support IE and edge which always show a 1px difference between offsetWidth and scrollWidth
        return this.elementRef.nativeElement.offsetWidth < (this.elementRef.nativeElement.scrollWidth - 1);
    };
    KTooltipDirective.prototype._removeTooltipElement = function () {
        if (this._tooltipElement) {
            if (this._tooltipElement.parentNode) {
                this._tooltipElement.parentNode.removeChild(this._tooltipElement);
            }
            this._tooltipElement = null;
            this._tooltipHeight = null;
            this._tooltipWidth = null;
        }
    };
    KTooltipDirective.prototype._isShowingTooltip = function () {
        return this._tooltipElement !== null;
    };
    KTooltipDirective.prototype._updateTooltipElementContent = function () {
        if (this._isShowingTooltip() && this._tooltipContent) {
            var content = '';
            if (this.tooltipResolver && typeof this.tooltipResolver === 'string') {
                content = this._tooltipContent[this.tooltipResolver];
            }
            else if (this.tooltipResolver && typeof this.tooltipResolver === 'function') {
                content = this.tooltipResolver(this._tooltipContent);
            }
            else {
                content = this._tooltipContent;
            }
            if (this.isValidContent(content)) {
                // re-check content type to handle scenarios when the tooltipResolver caused the value to be undefined
                this._tooltipElement.innerHTML = '';
                this._tooltipElement.textContent = '';
                if (this.escape) {
                    this._tooltipElement.textContent = content;
                }
                else {
                    this._tooltipElement.innerHTML = content;
                }
                this._tooltipHeight = this._tooltipElement.clientHeight;
                this._tooltipWidth = this._tooltipElement.offsetWidth;
                return true;
            }
            else {
                this._removeTooltipElement();
                return false;
            }
        }
    };
    KTooltipDirective.prototype._updateTooltipElementPosition = function () {
        if (this._isShowingTooltip()) {
            var elemPosition = this.elementRef.nativeElement.getBoundingClientRect();
            if (elemPosition) {
                var elemHeight = this.elementRef.nativeElement.offsetHeight;
                var elemWidth = this.elementRef.nativeElement.offsetWidth;
                if (this.placement == 'top') {
                    this._tooltipElement.style.top = elemPosition.top - (this._tooltipHeight + this.tooltipOffset) + 'px';
                }
                if (this.placement == 'bottom') {
                    this._tooltipElement.style.top = elemPosition.top + elemHeight + this.tooltipOffset + 'px';
                }
                if (this.placement == 'top' || this.placement == 'bottom') {
                    this._tooltipElement.style.left = (elemPosition.left + elemWidth / 2) - this._tooltipWidth / 2 + 'px';
                }
                if (this.placement == 'left') {
                    this._tooltipElement.style.left = elemPosition.left - this._tooltipWidth - this.tooltipOffset + 'px';
                }
                if (this.placement == 'right') {
                    this._tooltipElement.style.left = elemPosition.left + elemWidth + this.tooltipOffset + 'px';
                }
                if (this.placement == 'left' || this.placement == 'right') {
                    this._tooltipElement.style.top = elemPosition.top + elemHeight / 2 - this._tooltipElement.clientHeight / 2 + 'px';
                }
                // correct left positioning of tooltip if outside the screen
                var offsetLeft = parseInt(this._tooltipElement.style.left);
                if (offsetLeft < 0) {
                    this._tooltipElement.style.left = 0 + 'px';
                }
            }
        }
        else {
            this._updateTooltipElement();
        }
    };
    KTooltipDirective.prototype.ngOnDestroy = function () {
        this._removeTooltipElement();
    };
    KTooltipDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], KTooltipDirective.prototype, "tooltipResolver", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], KTooltipDirective.prototype, "escape", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], KTooltipDirective.prototype, "tooltipOffset", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], KTooltipDirective.prototype, "placement", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], KTooltipDirective.prototype, "delay", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], KTooltipDirective.prototype, "maxWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], KTooltipDirective.prototype, "followTarget", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], KTooltipDirective.prototype, "showOnEllipsis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], KTooltipDirective.prototype, "kTooltip", null);
    __decorate([
        HostListener("mousemove"),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], KTooltipDirective.prototype, "onMouseMove", null);
    __decorate([
        HostListener("mouseenter"),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], KTooltipDirective.prototype, "onMouseEnter", null);
    __decorate([
        HostListener("mouseleave"),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], KTooltipDirective.prototype, "onMouseLeave", null);
    KTooltipDirective = __decorate([
        Directive({
            selector: '[kTooltip]'
        }),
        __metadata("design:paramtypes", [ElementRef])
    ], KTooltipDirective);
    return KTooltipDirective;
}());

var TooltipModule = /** @class */ (function () {
    function TooltipModule() {
    }
    TooltipModule = __decorate([
        NgModule({
            imports: [
                CommonModule
            ],
            declarations: [
                KTooltipDirective
            ],
            exports: [
                KTooltipDirective
            ]
        })
    ], TooltipModule);
    return TooltipModule;
}());

var DetailsBarModule = /** @class */ (function () {
    function DetailsBarModule() {
    }
    DetailsBarModule = __decorate([
        NgModule({
            imports: [
                CommonModule,
                TooltipModule
            ],
            declarations: [
                DetailsBarComponent,
                DetailInfoComponent
            ],
            exports: [
                DetailsBarComponent,
                DetailInfoComponent
            ],
            providers: []
        })
    ], DetailsBarModule);
    return DetailsBarModule;
}());

;
var DynamicFormControlBase = /** @class */ (function () {
    function DynamicFormControlBase(options) {
        this.defaultValue = options.value;
        this.key = options.key || '';
        this.label = options.label || '';
        this.allowMultiple = !!options.allowMultiple;
        this.order = options.order === undefined ? 1 : options.order;
        this.description = options.description || '';
        this.validators = options.validators;
        this.validateOn = options.validateOn || 'change';
        this.errors = options.errors;
        this.inputHelperConfig = options.inputHelperConfig;
        this.styleClass = options.styleClass;
        this.dateFormat = options.dateFormat;
    }
    return DynamicFormControlBase;
}());

var DynamicSectionControl = /** @class */ (function (_super) {
    __extends(DynamicSectionControl, _super);
    function DynamicSectionControl(options) {
        var _this = _super.call(this, options) || this;
        _this.children = options.children;
        return _this;
    }
    Object.defineProperty(DynamicSectionControl.prototype, "controlType", {
        get: function () {
            return 'Group';
        },
        enumerable: true,
        configurable: true
    });
    return DynamicSectionControl;
}(DynamicFormControlBase));

var DynamicFormService = /** @class */ (function () {
    function DynamicFormService(_formBuilder) {
        this._formBuilder = _formBuilder;
    }
    DynamicFormService.prototype.toFormGroup = function (dynamicControls, config) {
        var _this = this;
        if (config === void 0) { config = {}; }
        var result = {};
        if (dynamicControls) {
            dynamicControls.forEach(function (formControl) {
                if (!config.ignoreMultiple && formControl.allowMultiple) {
                    var formArray_1 = result[formControl.key] = _this._formBuilder.array([]);
                    if (config && config.formValue) {
                        // build array formGroup item for each actual record in array
                        var arrayItems = config.formValue[formControl.key];
                        if (arrayItems instanceof Array) {
                            arrayItems.forEach(function (arrayItem) {
                                formArray_1.push(_this.toFormGroup([formControl], {
                                    ignoreMultiple: true,
                                    formValue: arrayItem
                                }));
                            });
                        }
                    }
                }
                else {
                    if (formControl instanceof DynamicSectionControl) {
                        var shouldCreateNestedGroup = dynamicControls.length > 1;
                        if (shouldCreateNestedGroup) {
                            result[formControl.key] = _this.toFormGroup(formControl.children, { formValue: config.formValue });
                        }
                        else {
                            result = _this.toFormGroup(formControl.children, { formValue: config.formValue });
                        }
                    }
                    else {
                        result[formControl.key] = new FormControl(formControl.defaultValue || null, { validators: formControl.validators, updateOn: formControl.validateOn ? formControl.validateOn : 'change' });
                    }
                }
            });
        }
        return (result instanceof FormGroup) ? result : this._formBuilder.group(result);
    };
    DynamicFormService.ctorParameters = function () { return [
        { type: FormBuilder }
    ]; };
    DynamicFormService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [FormBuilder])
    ], DynamicFormService);
    return DynamicFormService;
}());

var DynamicFormItem = /** @class */ (function () {
    function DynamicFormItem(_formBuilder, _dynamicFormService) {
        this._formBuilder = _formBuilder;
        this._dynamicFormService = _dynamicFormService;
    }
    DynamicFormItem.prototype.asDynamicSection = function (control) {
        return control;
    };
    DynamicFormItem.prototype.asFormGroup = function (control) {
        return control;
    };
    DynamicFormItem.prototype.ngOnInit = function () {
        this.isRequired = false;
        var validators = this.control.validators;
        if (this.control.validators) {
            var RequiredValidator = validators.find(function (validator) {
                return validator == Validators.required;
            });
            if (RequiredValidator) {
                this.isRequired = true;
            }
        }
    };
    DynamicFormItem.prototype.initItem = function (dynamicControl) {
        return this._dynamicFormService.toFormGroup([dynamicControl], { ignoreMultiple: true });
    };
    DynamicFormItem.prototype.addItem = function (dynamicControl) {
        var control = this.form.controls[dynamicControl.key];
        control.push(this.initItem(dynamicControl));
        control.markAsDirty();
    };
    DynamicFormItem.prototype.removeItem = function (dynamicControl, i) {
        var control = this.form.controls[dynamicControl.key];
        control.removeAt(i);
        control.markAsDirty();
    };
    DynamicFormItem.ctorParameters = function () { return [
        { type: FormBuilder },
        { type: DynamicFormService }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", DynamicFormControlBase)
    ], DynamicFormItem.prototype, "control", void 0);
    __decorate([
        Input(),
        __metadata("design:type", FormGroup)
    ], DynamicFormItem.prototype, "form", void 0);
    __decorate([
        ContentChildren(TemplateRef, { descendants: false }),
        __metadata("design:type", QueryList)
    ], DynamicFormItem.prototype, "_templates", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], DynamicFormItem.prototype, "labelTemplate", void 0);
    DynamicFormItem = __decorate([
        Component({
            selector: 'k-dynamic-form-item',
            template: "<div *ngIf=\"control\" [formGroup]=\"form\">\n\n    <ng-container  *ngIf=\"control.controlType === 'Group' && control.allowMultiple\">\n            <div class=\"kMultiple\" [formArrayName]=\"control.key\">\n                <span class=\"kGroupTitle\" *ngIf=\"control.label\">\n                    <span [kTooltip]=\"control.description\">{{control.label}}</span>\n                </span>\n                <div class=\"kGroupContainer\"  *ngFor=\"let groupForm of asFormGroup(form.controls[control.key]).controls; let i=index\">\n\n                    <div [formGroupName]=\"i\">\n                        <k-dynamic-form-item *ngFor=\"let childControl of asDynamicSection(control).children\"\n                                          [control]=\"childControl\"\n                                          [form]=\"groupForm\">\n                            <ng-template let-item=\"item\">\n                                <ng-container *ngTemplateOutlet=\"_templates.first;context:{ item : item }\">\n                                </ng-container>\n                            </ng-template>\n                        </k-dynamic-form-item>\n                    </div>\n\n                    <div class=\"kDeleteGroup\">\n                        <a (click)=\"!form.disabled && removeItem(control,i)\" [class.disabled]=\"form.disabled\">Delete</a>\n                    </div>\n                </div>\n\n                <div class=\"kGroupButtons\">\n                    <button (click)=\"addItem(control)\" class=\"kButton\" [disabled]=\"form.disabled\">Add</button>\n                </div>\n            </div>\n    </ng-container>\n\n    <div class=\"kMultiple\" *ngIf=\"control.controlType === 'Group' && !control.allowMultiple\">\n        <span class=\"kGroupTitle\" *ngIf=\"control.label\">\n            <span [kTooltip]=\"control.description\">{{control.label}}</span>\n        </span>\n        <k-dynamic-form-item *ngFor=\"let childControl of asDynamicSection(control).children\" [control]=\"childControl\" [form]=\"form\" [labelTemplate]=\"labelTemplate\">\n            <ng-template let-item=\"item\">\n                <ng-container *ngTemplateOutlet=\"_templates.first;context:{ item : item }\"></ng-container>\n            </ng-template>\n        </k-dynamic-form-item>\n    </div>\n\n    <div class=\"kRow\" [ngClass]=\"control.styleClass\" *ngIf=\"control.controlType !== 'Group'\">\n        <div class=\"kFormLabelContainer\">\n            <span class=\"kLabel\" *ngIf=\"control.label && !!labelTemplate == false\">{{control.label}}\n                <kInputHelper *ngIf=\"control.inputHelperConfig && control.inputHelperConfig.body\" [title]=\"control.inputHelperConfig.title\">\n                    <span [innerHTML]=\"control.inputHelperConfig.body\"></span>\n                </kInputHelper>\n            </span>\n            <ng-container *ngIf=\"!!labelTemplate\">\n                <ng-container *ngTemplateOutlet=\"labelTemplate;context:{item: { control : control, form : form, isRequired : isRequired }}\"></ng-container>\n            </ng-container>\n            <span *ngIf=\"isRequired\" class=\"kFormRequiredIndicator\">*</span>\n        </div>\n        <div class=\"kMultiple\" *ngIf=\"control.allowMultiple\" [formArrayName]=\"control.key\">\n\n            <div class=\"kSingleItem\" *ngFor=\"let itemFormGroup of asFormGroup(form.controls[control.key]).controls; let i=index\" [formGroupName]=\"i\">\n                    <ng-container *ngTemplateOutlet=\"_templates.first;context:{item: { control : control, form : itemFormGroup }}\"></ng-container>\n                <a (click)=\"!form.disabled && removeItem(control,i)\" class=\"kDelete\" [class.disabled]=\"form.disabled\">Delete</a>\n            </div>\n            <div>\n                <button class=\"kButton\" (click)=\"!form.disabled && addItem(control)\" [disabled]=\"form.disabled\">Add</button>\n            </div>\n        </div>\n\n        <div class=\"kControl\" [ngClass]=\"[control.controlType, control.key + 'Control']\" *ngIf=\"!control.allowMultiple\">\n            <ng-container *ngTemplateOutlet=\"_templates.first;context:{item: { control : control, form : form }}\"></ng-container>\n        </div>\n        <!--<div class=\"errorMessage\" *ngIf=\"form.controls[control.key].valid\">{{control.label}} is required</div>-->\n    </div>\n</div>\n\n",
            styles: [""]
        }),
        __metadata("design:paramtypes", [FormBuilder, DynamicFormService])
    ], DynamicFormItem);
    return DynamicFormItem;
}());

var PopupWidgetLayout = /** @class */ (function () {
    function PopupWidgetLayout() {
    }
    PopupWidgetLayout.getPopupZindex = function (isFullScreen) {
        if (isFullScreen === void 0) { isFullScreen = false; }
        if (isFullScreen) {
            return 1000;
        }
        PopupWidgetLayout.popupWidgetInitialZindex += 2;
        return PopupWidgetLayout.popupWidgetInitialZindex;
    };
    PopupWidgetLayout.increaseModalCount = function () {
        PopupWidgetLayout.modalsCount++;
        if (PopupWidgetLayout.modalsCount === 1) {
            document.body.classList.add("kModal");
        }
    };
    PopupWidgetLayout.decreaseModalCount = function () {
        PopupWidgetLayout.modalsCount--;
        if (PopupWidgetLayout.modalsCount === 0) {
            document.body.classList.remove("kModal");
        }
        if (PopupWidgetLayout.modalsCount < 0) {
            PopupWidgetLayout.modalsCount = 0;
        }
    };
    PopupWidgetLayout.popupWidgetInitialZindex = 600;
    PopupWidgetLayout.modalsCount = 0;
    return PopupWidgetLayout;
}());

var PopupWidgetStates = {
    "Open": "open",
    "BeforeClose": "beforeClose",
    "Close": "close",
    "Disabled": "disabled"
};
var WINDOW_GUTTER = 16;
var PopupWidgetComponent = /** @class */ (function () {
    function PopupWidgetComponent(popup, renderer) {
        var _this = this;
        this.popup = popup;
        this.renderer = renderer;
        this.transparent = false;
        this.popupHeight = 'auto';
        this.showTooltip = false;
        this.preventPageScroll = false;
        this.modal = false;
        this.slider = false;
        this.fullScreen = false;
        this.closeBtn = true;
        this.closeBtnInside = false;
        this.closeOnClickOutside = true;
        this.closeOnResize = false;
        this.closeOnBrowserNav = true;
        this.targetOffset = { 'x': 0, 'y': 0 };
        this.childrenPopups = [];
        this.trigger = 'click';
        this.placement = { x: 'right', y: 'bottom' };
        this.closeOnScroll = false;
        this.opened = false;
        this.closed = false;
        this._toggleFunc = this.toggle.bind(this);
        this._openFunc = this.open.bind(this);
        this._closeFunc = this.close.bind(this);
        this._viewInitialize = false;
        this.onOpen = new EventEmitter();
        this.onClose = new EventEmitter();
        this._stateChangeSubscription = null;
        this._statechange = new BehaviorSubject({ state: '' });
        this.state$ = this._statechange.asObservable();
        this._statechange.next({ state: PopupWidgetStates.Close });
        this.state$
            .pipe(cancelOnDestroy(this))
            .subscribe(function (_a) {
            var state = _a.state;
            _this.closed = state === PopupWidgetStates.Close;
            _this.opened = state === PopupWidgetStates.Open;
        });
    }
    Object.defineProperty(PopupWidgetComponent.prototype, "targetRef", {
        get: function () { return this._targetRef; },
        set: function (targetRef) {
            if (this.trigger === 'click') {
                if (this._targetRef) {
                    this._targetRef.removeEventListener('click', this._toggleFunc);
                }
                this._targetRef = targetRef;
                if (this._targetRef) {
                    this._targetRef.addEventListener('click', this._toggleFunc);
                }
            }
            else if (this.trigger === 'hover') {
                if (this._targetRef) {
                    this._targetRef.removeEventListener('mouseover', this._openFunc);
                    this._targetRef.removeEventListener('mouseout', this._closeFunc);
                }
                this._targetRef = targetRef;
                if (this._targetRef) {
                    this._targetRef.addEventListener('mouseover', this._openFunc);
                    this._targetRef.addEventListener('mouseout', this._closeFunc);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PopupWidgetComponent.prototype, "parentPopup", {
        get: function () { return this._parentPopup; },
        set: function (parentPopup) {
            var _this = this;
            this._parentPopup = parentPopup;
            if (this._stateChangeSubscription) {
                this._stateChangeSubscription.unsubscribe();
                this._stateChangeSubscription = null;
            }
            if (this._parentPopup) {
                this._stateChangeSubscription = this._parentPopup.state$.subscribe(function (event) {
                    if (event.state === PopupWidgetStates.Close) {
                        _this.close();
                    }
                });
            }
        },
        enumerable: true,
        configurable: true
    });
    // public API methods
    PopupWidgetComponent.prototype.open = function () {
        var _this = this;
        if (this.isEnabled && this.validate()) {
            // handle auto height
            if (!this.popupHeight || this.popupHeight === 'auto') {
                if (this.slider) {
                    this._popupWidgetHeight = 'calc(100vh - 80px)';
                }
                else {
                    this._popupWidgetHeight = 'auto';
                }
            }
            else {
                this._popupWidgetHeight = this.popupHeight + "px";
            }
            this._saveScrollPosition = window.pageYOffset || document.documentElement.scrollTop;
            // set location according to targetRef
            var parentLeft = this.appendTo && !this.modal ? this.appendTo.getBoundingClientRect().left : 0;
            var parentTop = this.appendTo && !this.modal ? this.appendTo.getBoundingClientRect().top : 0;
            // center on screen if no targetRef was defined
            if (!this._targetRef) {
                if (this.fullScreen) {
                    this.modal = false;
                    this.preventPageScroll = true;
                    this.renderer.addClass(this.popup.nativeElement, 'fullScreen');
                }
                else {
                    this.popup.nativeElement.style.marginLeft = window.innerWidth / 2 - this.popupWidth / 2 + 'px';
                    if (this.slider) {
                        window.scrollTo(0, 0);
                        this.popup.nativeElement.style.top = "auto";
                        this.closeBtn = false;
                        this.preventPageScroll = true;
                        this.popup.nativeElement.style.bottom = this.popupHeight !== 'auto' ? this.popupHeight * -1 + "px" : "-1000px";
                        setTimeout(function () {
                            _this.popup.nativeElement.style.bottom = 0 + "px"; // use timeout to invoke animation
                        }, 0);
                    }
                    else {
                        var marginTop = (window.innerHeight / 2 - 100 / 2);
                        this.popup.nativeElement.style.marginTop = marginTop + 'px';
                        this.popup.nativeElement.style.position = "fixed";
                    }
                }
            }
            else {
                this.popup.nativeElement.style.marginLeft = this._targetRef.getBoundingClientRect().left - parentLeft + this.targetOffset['x'] + 'px';
                this.popup.nativeElement.style.marginTop = this._targetRef.getBoundingClientRect().top - parentTop + this.targetOffset['y'] + 'px';
                this.popup.nativeElement.style.position = "absolute";
            }
            this.popup.nativeElement.style.zIndex = PopupWidgetLayout.getPopupZindex(this.fullScreen);
            // handle modal
            if (!this._modalOverlay) {
                if (this.trigger !== 'hover') {
                    this._modalOverlay = document.createElement('div');
                    if (this.modal || this.slider) {
                        this._modalOverlay.className = "kPopupWidgetModalOverlay";
                    }
                    else {
                        this._modalOverlay.className = "kPopupWidgetModalOverlay kTransparent";
                    }
                    this._modalOverlay.style.zIndex = this.popup.nativeElement.style.zIndex - 1;
                    if (!this.slider && this.closeOnClickOutside) {
                        this._modalOverlay.addEventListener("mousedown", function (event) {
                            event.stopPropagation();
                            _this.close();
                        });
                    }
                    if (this.appendTo) {
                        this.appendChild(this._modalOverlay, this.appendTo);
                    }
                    else {
                        document.body.appendChild(this._modalOverlay);
                    }
                    if (this.modal || this.slider) {
                        PopupWidgetLayout.increaseModalCount();
                    }
                }
            }
            // prevent page scroll
            if (this.preventPageScroll) {
                document.body.style.overflowY = 'hidden';
                document.body.style.position = 'fixed';
            }
            setTimeout(function () {
                _this.addClickOutsideSupport();
            }, 0);
            this.onOpen.emit(); // dispatch onOpen event (API)
            this._statechange.next({ state: PopupWidgetStates.Open });
            if (this.closeOnScroll && this.isShow) {
                window.addEventListener('scroll', this._closeFunc);
            }
        }
        if (!this.slider && !this.fullScreen && this.popup.nativeElement) {
            this.popup.nativeElement.style.opacity = 0;
        }
        // auto positioning need first the dom to render
        setTimeout(function () {
            _this.setPosition();
        }, 0);
    };
    PopupWidgetComponent.prototype.close = function (context, reason) {
        var _this = this;
        if (context === void 0) { context = null; }
        if (reason === void 0) { reason = null; }
        if (this.isEnabled && this.isShow) {
            window.removeEventListener('scroll', this._closeFunc);
            if (this.fullScreen) {
                this.renderer.removeClass(this.popup.nativeElement, 'fullScreen');
            }
            // allow cancelling the close operation
            var beforeCloseContext = { "allowClose": true };
            this._statechange.next({ state: PopupWidgetStates.BeforeClose, context: beforeCloseContext });
            if (beforeCloseContext['allowClose']) {
                // close children popups if exist
                if (this.childrenPopups.length) {
                    this.childrenPopups.forEach(function (popup) {
                        popup.close();
                    });
                }
                this.removeClickOutsideSupport();
                this.restorePageScroll(true);
                this.onClose.emit(); // dispatch onClose event (API)
                var timeout = 0;
                if (this.slider) {
                    this.popup.nativeElement.style.bottom = this.popupHeight !== 'auto' ? this.popupHeight * -1 + "px" : "-1000px";
                    timeout = 300;
                }
                if (this.modal && !this.slider) {
                    PopupWidgetLayout.decreaseModalCount();
                }
                setTimeout(function () {
                    // remove modal
                    if (_this._modalOverlay) {
                        if (_this.appendTo) {
                            _this.removeChild(_this._modalOverlay, _this.appendTo);
                        }
                        else {
                            document.body.removeChild(_this._modalOverlay);
                        }
                        _this._modalOverlay = null;
                    }
                    if (_this.slider) {
                        PopupWidgetLayout.decreaseModalCount();
                    }
                    _this._statechange.next({ state: PopupWidgetStates.Close, context: context, reason: reason }); // use timeout to prevent valueChangeAfterChecked error
                }, timeout);
            }
        }
    };
    PopupWidgetComponent.prototype.toggle = function () {
        if (this.isEnabled) {
            this.isShow ? this.close() : this.open();
        }
    };
    Object.defineProperty(PopupWidgetComponent.prototype, "isShow", {
        get: function () {
            return this._statechange.getValue().state !== PopupWidgetStates.Close;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PopupWidgetComponent.prototype, "isEnabled", {
        get: function () {
            return this._statechange.getValue().state !== PopupWidgetStates.Disabled;
        },
        enumerable: true,
        configurable: true
    });
    PopupWidgetComponent.prototype.onWindowResize = function () {
        if (this.closeOnResize) {
            this.close();
        }
        else {
            this.setPosition();
        }
    };
    PopupWidgetComponent.prototype.onPopState = function (event) {
        if (this.closeOnBrowserNav) {
            this.close();
        }
    };
    // component lifecycle events
    PopupWidgetComponent.prototype.ngAfterViewInit = function () {
        this._viewInitialize = true;
        if (this.validate()) {
            if (this.appendTo && !this.modal) {
                this.appendChild(this.popup.nativeElement, this.appendTo);
            }
            else {
                document.body.appendChild(this.popup.nativeElement);
                if (this.appendTo) {
                    console.warn("[kaltura] -> Ignoring append to " + this.appendTo + " since popup is set to modal=true."); // keep warning
                }
            }
            if (this.fullScreen) {
                this.popup.nativeElement.style.width = '0px';
                this.popup.nativeElement.style.height = '0px';
            }
        }
    };
    PopupWidgetComponent.prototype.ngOnDestroy = function () {
        if (this._targetRef) {
            this._targetRef.removeEventListener('click', this._toggleFunc);
            this._targetRef.removeEventListener('mouseover', this._openFunc);
            this._targetRef.removeEventListener('mouseout', this._closeFunc);
        }
        if (this._stateChangeSubscription) {
            this._stateChangeSubscription.unsubscribe();
        }
        this._statechange.complete();
        this.removeClickOutsideSupport();
        this.restorePageScroll(false);
        if (this.modal && this._modalOverlay) {
            document.body.removeChild(this._modalOverlay);
            this._modalOverlay = null;
        }
        if (this.appendTo && !this.modal) {
            this.removeChild(this.popup.nativeElement, this.appendTo);
        }
        else {
            if (this._viewInitialize) {
                document.body.removeChild(this.popup.nativeElement);
            }
        }
        window.removeEventListener('scroll', this._closeFunc);
    };
    // private methods
    PopupWidgetComponent.prototype.addClickOutsideSupport = function () {
        if (this.closeOnClickOutside) {
            this.popup.nativeElement.addEventListener('mousedown', this.blockMouseDownHandler);
            if (this.targetRef) {
                this.targetRef.addEventListener('mousedown', this.blockMouseDownHandler);
            }
        }
    };
    PopupWidgetComponent.prototype.blockMouseDownHandler = function (event) {
        event.stopPropagation();
    };
    PopupWidgetComponent.prototype.removeClickOutsideSupport = function () {
        if (this.closeOnClickOutside) {
            this.popup.nativeElement.removeEventListener('mousedown', this.blockMouseDownHandler);
            if (this.targetRef) {
                this.targetRef.removeEventListener('mousedown', this.blockMouseDownHandler);
            }
        }
    };
    PopupWidgetComponent.prototype.restorePageScroll = function (restoreScrollPosition) {
        if (restoreScrollPosition === void 0) { restoreScrollPosition = true; }
        if (this.preventPageScroll) {
            document.body.style.overflowY = 'auto';
            document.body.style.position = '';
            if (restoreScrollPosition) {
                window.scrollTo(0, this._saveScrollPosition);
            }
        }
    };
    PopupWidgetComponent.prototype.validate = function () {
        var valid = typeof this.popupWidth !== 'undefined' || this.fullScreen;
        if (!valid) {
            this._statechange.next({ state: PopupWidgetStates.Disabled });
            throw "Popup widget error: missing required parameters. Verify popupWidth is defined.";
        }
        return valid;
    };
    PopupWidgetComponent.prototype.appendChild = function (element, target) {
        if (this.isElement(target)) {
            target.appendChild(element);
        }
        else {
            throw 'Cannot append ' + target + ' to ' + element;
        }
    };
    PopupWidgetComponent.prototype.removeChild = function (element, target) {
        if (this.isElement(target)) {
            target.removeChild(element);
        }
        else {
            throw 'Cannot remove ' + target + ' from ' + element;
        }
    };
    PopupWidgetComponent.prototype.isElement = function (obj) {
        return (typeof HTMLElement === "object" ? obj instanceof HTMLElement :
            obj && typeof obj === "object" && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === "string");
    };
    PopupWidgetComponent.prototype.setPosition = function () {
        var popupHeight = this.popup.nativeElement.clientHeight;
        var popupWidth = this.popup.nativeElement.clientWidth;
        if (this.modal || this.slider) {
            this.popup.nativeElement.style.marginLeft = window.innerWidth / 2 - this.popupWidth / 2 + 'px';
            if (this.modal) {
                var modalMarginTop = (window.innerHeight / 2 -
                    popupHeight / 2);
                this.popup.nativeElement.style.marginTop = Math.round(modalMarginTop) + 'px';
                this.popup.nativeElement.style.opacity = 1;
            }
            return;
        }
        if (!this._targetRef)
            return;
        var popupBox = this.popup.nativeElement.getBoundingClientRect();
        var targetRefBox = this._targetRef.getBoundingClientRect();
        var parentTop = this.appendTo && !this.modal ? this.appendTo.getBoundingClientRect().top : 0;
        var parentLeft = this.appendTo && !this.modal ? this.appendTo.getBoundingClientRect().left : 0;
        var popupMarginTop;
        var popupMarginLeft;
        var popupLeftMargins = {};
        var popupTopMargins = {};
        popupTopMargins.top = (targetRefBox.top
            - parentTop
            - popupHeight
            + this.targetRef.offsetHeight
            - this.targetOffset['y']);
        popupTopMargins.bottom = (targetRefBox.top
            - parentTop
            + this.targetOffset['y']);
        popupTopMargins.center = (targetRefBox.top
            - parentTop
            - popupHeight / 2
            + this.targetRef.offsetHeight / 2
            + this.targetOffset['y']);
        popupLeftMargins.left = (targetRefBox.left
            - parentLeft
            - popupWidth
            + this.targetRef.clientWidth
            - this.targetOffset['x']);
        popupLeftMargins.right = (targetRefBox.left
            - parentLeft
            + this.targetOffset['x']);
        popupLeftMargins.center = (targetRefBox.left
            - parentLeft
            - popupWidth / 2
            + this.targetOffset['x']);
        popupMarginTop = this.placement.y ? popupTopMargins[this.placement.y] : popupTopMargins.bottom;
        popupMarginLeft = this.placement.x ? popupLeftMargins[this.placement.y] : popupLeftMargins.right;
        this.popup.nativeElement.style.marginTop = Math.round(popupMarginTop) + 'px';
        this.popup.nativeElement.style.marginLeft = Math.round(popupMarginLeft) + 'px';
        this.validatePosition(popupLeftMargins, popupTopMargins);
    };
    // validate popup widget is not outside of the viewport (+ gutter) and if it is, reposition it
    PopupWidgetComponent.prototype.validatePosition = function (popupLeftMargins, popupTopMargins) {
        var popupHeight = this.popup.nativeElement.clientHeight;
        var popupWidth = this.popup.nativeElement.clientWidth;
        var popupBox = this.popup.nativeElement.getBoundingClientRect();
        var clientHeight = window.innerHeight;
        var clientWidth = window.innerWidth;
        var popupMarginTop;
        var popupMarginLeft;
        if (this.placement.y === 'top') {
            if (popupBox.top < WINDOW_GUTTER) {
                popupMarginTop = popupTopMargins.bottom;
            }
        }
        else if (this.placement.y === 'bottom') {
            if (popupBox.top + popupHeight > clientHeight - WINDOW_GUTTER && popupBox.top > clientHeight) {
                popupMarginTop = popupTopMargins.top;
            }
            else {
                popupMarginTop = popupTopMargins.bottom;
            }
        }
        else if (this.placement.y === 'center') {
            if (popupBox.top < WINDOW_GUTTER) {
                popupMarginTop = popupTopMargins.bottom;
            }
            else if (popupBox.top + popupHeight > clientHeight - WINDOW_GUTTER) {
                popupMarginTop = popupTopMargins.top;
            }
        }
        if (popupBox.left + popupWidth > clientWidth + WINDOW_GUTTER) {
            popupMarginLeft = popupLeftMargins.left;
        }
        else if (popupBox.left < WINDOW_GUTTER) {
            popupMarginLeft = popupLeftMargins.right;
        }
        this.popup.nativeElement.style.marginTop = Math.round(popupMarginTop) + 'px';
        this.popup.nativeElement.style.marginLeft = Math.round(popupMarginLeft) + 'px';
        this.popup.nativeElement.style.opacity = 1;
    };
    PopupWidgetComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PopupWidgetComponent.prototype, "transparent", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PopupWidgetComponent.prototype, "appendTo", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PopupWidgetComponent.prototype, "popupWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PopupWidgetComponent.prototype, "popupHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PopupWidgetComponent.prototype, "showTooltip", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PopupWidgetComponent.prototype, "preventPageScroll", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PopupWidgetComponent.prototype, "modal", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PopupWidgetComponent.prototype, "slider", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PopupWidgetComponent.prototype, "fullScreen", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PopupWidgetComponent.prototype, "closeBtn", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PopupWidgetComponent.prototype, "closeBtnInside", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PopupWidgetComponent.prototype, "closeOnClickOutside", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PopupWidgetComponent.prototype, "closeOnResize", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PopupWidgetComponent.prototype, "closeOnBrowserNav", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PopupWidgetComponent.prototype, "targetOffset", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PopupWidgetComponent.prototype, "childrenPopups", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PopupWidgetComponent.prototype, "trigger", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PopupWidgetComponent.prototype, "placement", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PopupWidgetComponent.prototype, "closeOnScroll", void 0);
    __decorate([
        ContentChild(TemplateRef, { static: true }),
        __metadata("design:type", TemplateRef)
    ], PopupWidgetComponent.prototype, "_template", void 0);
    __decorate([
        HostBinding('class.opened'),
        __metadata("design:type", Object)
    ], PopupWidgetComponent.prototype, "opened", void 0);
    __decorate([
        HostBinding('class.closed'),
        __metadata("design:type", Object)
    ], PopupWidgetComponent.prototype, "closed", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], PopupWidgetComponent.prototype, "targetRef", null);
    __decorate([
        Input(),
        __metadata("design:type", PopupWidgetComponent),
        __metadata("design:paramtypes", [PopupWidgetComponent])
    ], PopupWidgetComponent.prototype, "parentPopup", null);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PopupWidgetComponent.prototype, "onOpen", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PopupWidgetComponent.prototype, "onClose", void 0);
    __decorate([
        HostListener("window:resize", []),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], PopupWidgetComponent.prototype, "onWindowResize", null);
    __decorate([
        HostListener('window:popstate', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], PopupWidgetComponent.prototype, "onPopState", null);
    PopupWidgetComponent = __decorate([
        Component({
            selector: 'kPopupWidget',
            template: "<div #container\n     class=\"kPopupWidget\"\n     [class.transparent]=\"transparent\"\n     [class.slider]=\"slider\"\n     [style.display]=\"(state$ | async)?.state !== 'close' ? 'block' : 'none'\"\n     [style.width]=\"popupWidth+'px'\"\n     [style.height]=\"_popupWidgetHeight\">\n    <div class=\"tooltipUp\" *ngIf=\"showTooltip\" [style.marginLeft]=\"popupWidth/2-12+'px'\"></div>\n    <i *ngIf=\"closeBtn\" class=\"kCloseBtn kIconclose_small\" [class.closeBtnInside]=\"closeBtnInside\" (click)=\"close()\"></i>\n    <div class=\"kPopupWidgetContent\" *ngIf=\"isShow\">\n        <ng-content *ngIf=\"!_template\"></ng-content>\n\t\t<ng-template *ngIf=\"_template\"\n\t\t\t[ngTemplateOutlet]=\"_template\">\n\t\t</ng-template>\n    </div>\n</div>\n",
            styles: [":host{position:absolute;left:0;top:0;transition:bottom .3s ease-in-out}:host.fullScreen{width:100%!important;height:100%!important;position:fixed}.kPopupWidget{background-color:#fff;border-radius:4px;box-shadow:0 16px 20px 0 rgba(0,0,0,.3)}.kPopupWidget.slider{border-bottom-right-radius:0;border-bottom-left-radius:0}.kPopupWidget.transparent{box-shadow:none;background:0}.kPopupWidget .kCloseBtn:not(.closeBtnInside){position:absolute;right:-118px;top:-62px;width:38px;height:38px;background-color:rgba(255,255,255,.2);border-radius:50%;text-align:center;padding-top:11px;padding-left:2px;box-sizing:border-box;color:#fff;cursor:pointer}.kPopupWidget .kCloseBtn:not(.closeBtnInside):hover{background-color:rgba(255,255,255,.4)}.kPopupWidget .kCloseBtn.closeBtnInside{font-size:14px;float:right;color:#999;margin-top:14px;margin-right:14px;cursor:pointer}.kPopupWidget .kCloseBtn.closeBtnInside:hover{color:#00a784}.kPopupWidget .tooltipUp{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAOCAYAAAA1+Nx+AAAAAXNSR0IArs4c6QAAAMpJREFUOBGtk0EOwiAQRcF0Z2JXspFTcAE9erkACXfADa50b3DGMAYjlGktSUNDhvfmlyLEguG9V86544ItQnKLEZxSslCfpJQXY8yNs3fHKcrwSSl1gGcE0cRN0k1AnSNca33ChkII1xjjA5Kce0lmE5SdExwF+I5CTpJmggI+lnAU0MhJ7nNnUhVw4FzJj2AJnCP5EmS4LQ+UIL25dfAfwT9wktckb8EW8JZEbgmvSQa8/mu+OcFqM/3WcBntAPA9LdSK165l5vMFmCyyP+zXS30AAAAASUVORK5CYII=);position:absolute;margin-top:-12px;width:24px;height:12px}"]
        }),
        __metadata("design:paramtypes", [ElementRef, Renderer2])
    ], PopupWidgetComponent);
    return PopupWidgetComponent;
}());

var PopupWidgetModule = /** @class */ (function () {
    function PopupWidgetModule() {
    }
    PopupWidgetModule = __decorate([
        NgModule({
            imports: [
                CommonModule
            ],
            declarations: [
                PopupWidgetComponent
            ],
            exports: [
                PopupWidgetComponent
            ],
            providers: []
        })
    ], PopupWidgetModule);
    return PopupWidgetModule;
}());

var InputHelperComponent = /** @class */ (function () {
    function InputHelperComponent() {
        this.trigger = 'hover';
        this.triggerIcon = 'kIconhelp_full';
        this.icon = 'kIconhelp';
        this.width = 300;
        this.placement = { x: 'right', y: 'top' };
    }
    InputHelperComponent.prototype.ngOnInit = function () { };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], InputHelperComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], InputHelperComponent.prototype, "trigger", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], InputHelperComponent.prototype, "triggerIcon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], InputHelperComponent.prototype, "icon", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], InputHelperComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], InputHelperComponent.prototype, "placement", void 0);
    InputHelperComponent = __decorate([
        Component({
            selector: 'kInputHelper',
            template: "<div class=\"kInputHelper\" #inputHelperContainer>\n    <a class=\"kIconhelpLink\" [class.kActive]=\"helperPopup.isShow\" #helperLink><i class=\"{{triggerIcon}}\"></i></a>\n\n    <kPopupWidget\n                  #helperPopup\n                  class=\"kInputHelperPopup\"\n                  [appendTo]=\"inputHelperContainer\"\n                  [targetOffset]=\"{x: 0, y: 20}\"\n                  [popupWidth]=\"width\"\n                  [closeBtn]=\"false\"\n                  [trigger]=\"trigger\"\n                  [placement]=\"placement\"\n                  [targetRef]=\"helperLink\">\n\n        <ng-template>\n            <div class=\"kInputHelperContainer kAverageElevation\">\n                <div *ngIf=\"title\" class=\"kInputHelperPopupHeader\">\n                    <i class=\"kIcon {{icon}}\"></i>\n                    {{title}}\n                </div>\n                <div class=\"kInputHelperPopupContent\">\n                    <ng-content></ng-content>\n                </div>\n            </div>\n        </ng-template>\n\n    </kPopupWidget>\n</div>\n",
            styles: [".kInputHelper{display:inline-block;vertical-align:middle;margin-left:6px;position:relative}.kInputHelper .kIconhelpLink{color:#999;text-decoration:none;position:relative;z-index:2}.kInputHelper .kIconhelpLink.kActive,.kInputHelper .kIconhelpLink:hover{color:#01accd}.kInputHelperPopup{border-radius:3px}.kInputHelperPopup ::ng-deep .kPopupWidget{box-shadow:none}.kInputHelperPopup .kInputHelperContainer{font-size:15px;line-height:20px;color:#999;padding:16px;border-radius:3px}.kInputHelperPopup .kInputHelperPopupHeader{color:#333;display:flex;align-items:center;padding-bottom:10px}.kInputHelperPopup .kInputHelperPopupHeader .kIcon{color:#999;font-size:24px;margin-right:14px}"]
        }),
        __metadata("design:paramtypes", [])
    ], InputHelperComponent);
    return InputHelperComponent;
}());

var InputHelperModule = /** @class */ (function () {
    function InputHelperModule() {
    }
    InputHelperModule = __decorate([
        NgModule({
            imports: [
                CommonModule,
                PopupWidgetModule
            ],
            declarations: [
                InputHelperComponent
            ],
            exports: [
                InputHelperComponent
            ],
            providers: []
        })
    ], InputHelperModule);
    return InputHelperModule;
}());

var DynamicFormModule = /** @class */ (function () {
    function DynamicFormModule() {
    }
    DynamicFormModule = __decorate([
        NgModule({
            imports: [
                ReactiveFormsModule,
                CommonModule,
                TooltipModule,
                InputHelperModule
            ],
            declarations: [
                DynamicFormItem
            ],
            exports: [
                DynamicFormItem
            ],
            providers: [
                DynamicFormService
            ]
        })
    ], DynamicFormModule);
    return DynamicFormModule;
}());

var ListControl = /** @class */ (function (_super) {
    __extends(ListControl, _super);
    function ListControl(options) {
        var _this = _super.call(this, options) || this;
        _this.values = options.values;
        return _this;
    }
    Object.defineProperty(ListControl.prototype, "controlType", {
        get: function () {
            return 'List';
        },
        enumerable: true,
        configurable: true
    });
    return ListControl;
}(DynamicFormControlBase));

var DatePickerControl = /** @class */ (function (_super) {
    __extends(DatePickerControl, _super);
    function DatePickerControl(options) {
        var _this = _super.call(this, options) || this;
        _this.showTime = false;
        _this.showTime = options.showTime;
        return _this;
    }
    Object.defineProperty(DatePickerControl.prototype, "controlType", {
        get: function () {
            return 'DatePicker';
        },
        enumerable: true,
        configurable: true
    });
    return DatePickerControl;
}(DynamicFormControlBase));

var TextAreaControl = /** @class */ (function (_super) {
    __extends(TextAreaControl, _super);
    function TextAreaControl(options) {
        return _super.call(this, options) || this;
    }
    Object.defineProperty(TextAreaControl.prototype, "controlType", {
        get: function () {
            return 'TextArea';
        },
        enumerable: true,
        configurable: true
    });
    return TextAreaControl;
}(DynamicFormControlBase));

var TextboxControl = /** @class */ (function (_super) {
    __extends(TextboxControl, _super);
    function TextboxControl(options) {
        return _super.call(this, options) || this;
    }
    Object.defineProperty(TextboxControl.prototype, "controlType", {
        get: function () {
            return 'Textbox';
        },
        enumerable: true,
        configurable: true
    });
    return TextboxControl;
}(DynamicFormControlBase));

var DynamicDropdownControl = /** @class */ (function (_super) {
    __extends(DynamicDropdownControl, _super);
    function DynamicDropdownControl(options) {
        var _this = _super.call(this, options) || this;
        _this.values = options.values;
        return _this;
    }
    Object.defineProperty(DynamicDropdownControl.prototype, "controlType", {
        get: function () {
            return 'Dropdown';
        },
        enumerable: true,
        configurable: true
    });
    return DynamicDropdownControl;
}(DynamicFormControlBase));

var SwitchControl = /** @class */ (function (_super) {
    __extends(SwitchControl, _super);
    function SwitchControl(options) {
        return _super.call(this, options) || this;
    }
    Object.defineProperty(SwitchControl.prototype, "controlType", {
        get: function () {
            return 'Switch';
        },
        enumerable: true,
        configurable: true
    });
    return SwitchControl;
}(DynamicFormControlBase));

var NumberControl = /** @class */ (function (_super) {
    __extends(NumberControl, _super);
    function NumberControl(options) {
        return _super.call(this, options) || this;
    }
    Object.defineProperty(NumberControl.prototype, "controlType", {
        get: function () {
            return 'Number';
        },
        enumerable: true,
        configurable: true
    });
    return NumberControl;
}(DynamicFormControlBase));

var KalturaPlayerComponent = /** @class */ (function () {
    function KalturaPlayerComponent() {
        this.width = 480;
        this.height = 360;
        this.cdnUrl = 'http://cdnapi.kaltura.com';
        this.flashvars = {};
        this.lazy = false;
        this.id = "";
        this.kalturaPlayerReady = new EventEmitter();
    }
    KalturaPlayerComponent.prototype.ngAfterViewInit = function () {
        if (!this.lazy) {
            this.Embed();
        }
    };
    KalturaPlayerComponent.prototype.Embed = function () {
        var _this = this;
        // validation
        if (!this.pid || !this.uiconfid || !this.entryid) {
            console.warn("Kaltura Player::Missing parameters. Please provide pid, uiconfid and entryid.");
        }
        else {
            // load player lib if doesn't exist
            if (document.getElementById("kalturaPlayerLib") === null) {
                var s = document.createElement('script');
                s.src = this.cdnUrl + "/p/" + this.pid + "/sp/" + this.pid + "00/embedIframeJs/uiconf_id/" + this.uiconfid + "/partner_id/" + this.pid;
                s.id = "kalturaPlayerLib";
                s.async = false;
                document.head.appendChild(s);
            }
            // wait for lib to load if not loaded and then embed player
            if (!this.kdp) {
                var intervalID_1 = setInterval(function () {
                    if (typeof window['kWidget'] !== "undefined") {
                        clearInterval(intervalID_1);
                        _this.doEmbed();
                    }
                }, 50);
            }
            else {
                this.doEmbed();
            }
        }
    };
    KalturaPlayerComponent.prototype.doEmbed = function () {
        var _this = this;
        window['kWidget'].embed({
            "targetId": "kaltura_player_" + this.id,
            "wid": "_" + this.pid,
            "uiconf_id": this.uiconfid,
            "flashvars": this.flashvars,
            "cache_st": Math.random(),
            "entry_id": this.entryid,
            "readyCallback": function (playerID) {
                _this.kdp = document.getElementById(playerID);
                _this.kalturaPlayerReady.emit(_this.kdp);
            }
        });
    };
    KalturaPlayerComponent.prototype.ngOnDestroy = function () {
        if (this.kdp) {
            window['kWidget'].destroy(this.kdp);
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], KalturaPlayerComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], KalturaPlayerComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], KalturaPlayerComponent.prototype, "pid", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], KalturaPlayerComponent.prototype, "uiconfid", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], KalturaPlayerComponent.prototype, "entryid", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], KalturaPlayerComponent.prototype, "cdnUrl", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], KalturaPlayerComponent.prototype, "flashvars", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], KalturaPlayerComponent.prototype, "lazy", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], KalturaPlayerComponent.prototype, "id", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], KalturaPlayerComponent.prototype, "kalturaPlayerReady", void 0);
    KalturaPlayerComponent = __decorate([
        Component({
            selector: 'k-player',
            template: "<div id=\"kaltura_player_{{id}}\" [style.width]=\"width+'px'\" [style.height]=\"height+'px'\" class=\"kPlayer\"></div>",
            styles: [".kPlayer{background-color:#000}"]
        }),
        __metadata("design:paramtypes", [])
    ], KalturaPlayerComponent);
    return KalturaPlayerComponent;
}());

var StickyScrollService = /** @class */ (function () {
    function StickyScrollService() {
        this._scrollSubject = new Subject();
        this.scrollStatus$ = this._scrollSubject.asObservable();
        this._resizeSubject = new Subject();
        this.resizeStatus$ = this._resizeSubject.asObservable();
        this._layoutSubject = new BehaviorSubject({});
        this.layoutSubject$ = this._layoutSubject.asObservable();
        this.stickyElements = {};
        this.manageScrollFunc = this.manageScrollEvent.bind(this);
        this.manageResizeFunc = this.manageResizeEvent.bind(this);
        window.addEventListener('scroll', this.manageScrollFunc);
        window.addEventListener('resize', this.manageResizeFunc);
    }
    StickyScrollService.prototype.ngOnDestroy = function () {
        window.removeEventListener('scroll', this.manageScrollFunc);
        window.removeEventListener('resize', this.manageResizeFunc);
    };
    StickyScrollService.prototype.manageScrollEvent = function () {
        this._scrollSubject.next({});
    };
    StickyScrollService.prototype.manageResizeEvent = function () {
        this._resizeSubject.next({});
    };
    StickyScrollService.prototype.attach = function (id) {
        if (!id) {
            throw new Error("sticky service::missing id on attach!");
        }
        else if (typeof this.stickyElements[id] !== "undefined") {
            throw new Error("sticky service::id already exists! (" + id + ")");
        }
        else {
            this.stickyElements[id] = null;
        }
    };
    StickyScrollService.prototype.detach = function (id) {
        if (!id) {
            console.warn("sticky service::missing id on attach!");
        }
        else {
            delete this.stickyElements[id];
        }
    };
    StickyScrollService.prototype.update = function (id, height, offset) {
        if (!id) {
            console.warn("sticky service::missing id!");
        }
        else {
            var currentValue = this.stickyElements[id];
            if (typeof currentValue !== "undefined") {
                if (currentValue === null || currentValue.height !== height || currentValue.offset !== offset) {
                    this.stickyElements[id] = { height: height, offset: offset };
                    this._layoutSubject.next(this.stickyElements);
                }
            }
            else {
                throw new Error("unknown sticky element '" + id + "' (did you attach it before updating?)");
            }
        }
    };
    StickyScrollService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [])
    ], StickyScrollService);
    return StickyScrollService;
}());

var StickyDirective = /** @class */ (function () {
    function StickyDirective(elementRef, renderer, _stickyScrollService) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this._stickyScrollService = _stickyScrollService;
        this.lastScroll = 0;
        this.isSticky = false;
        this._destroyed = false;
        this.onStickyEvent = new EventEmitter();
        this.onUnStickyEvent = new EventEmitter();
        this.scrollOffset = 0;
        this.stickyId = "";
        this.sticksTo = "";
        this.elementSelector = "";
        this._parentTop = null;
        this._parentOffset = null;
        this._stickyTop = null;
        this._stickyOffset = null;
    }
    StickyDirective.prototype._getStickyElement = function (elementRef) {
        return elementRef.nativeElement;
    };
    StickyDirective.prototype.ngAfterViewInit = function () {
        // console.log(`[${this.stickyId}] - ngAfterViewInit`);
        this._stickyElement = this._getStickyElement(this.elementRef);
        this.update();
    };
    StickyDirective.prototype.ngOnInit = function () {
        var _this = this;
        // console.log(`[${this.stickyId}] - attached`);
        if (this.stickyId) {
            this._stickyScrollService.attach(this.stickyId);
        }
        this._stickyScrollService.scrollStatus$.pipe(cancelOnDestroy(this)).subscribe(function (event) {
            // console.log(`[${this.stickyId}] - handle scroll`);
            _this._render();
        });
        this._stickyScrollService.resizeStatus$.pipe(cancelOnDestroy(this)).subscribe(function (event) {
            _this.onResize();
        });
        this._stickyScrollService.layoutSubject$.pipe(cancelOnDestroy(this)).subscribe(function (elements) {
            var data = _this.sticksTo ? elements[_this.sticksTo] : { height: 0, offset: 0 };
            if (data && (_this._parentTop !== data.height ||
                _this._parentOffset !== data.offset)) {
                _this._parentTop = data.height;
                _this._parentOffset = data.offset;
                _this.update();
            }
        });
    };
    StickyDirective.prototype.ngOnDestroy = function () {
        // console.log(`[${this.stickyId}] - destroyed`);
        this._destroyed = true;
        this._stickyScrollService.detach(this.stickyId);
    };
    StickyDirective.prototype.update = function () {
        var _this = this;
        if (this._parentTop !== null
            && this._parentOffset != null) {
            // console.log(`[${this.stickyId}] - handle layout update`);
            var stickyOffset = this._parentOffset + this.scrollOffset;
            if (this._stickyTop !== this._parentTop ||
                this._stickyOffset !== stickyOffset) {
                // console.log(`[${this.stickyId}] - update cached values`);
                this._stickyTop = this._parentTop;
                this._stickyOffset = stickyOffset;
                this._render();
            }
            if (this.stickyId && this._stickyElement) {
                // console.log(`[${this.stickyId}] - update service`);
                var elementHeight_1 = this._stickyElement.getBoundingClientRect()['height'];
                setTimeout(function () {
                    _this._stickyScrollService.update(_this.stickyId, elementHeight_1 + _this._stickyTop, _this._stickyOffset);
                }, 0);
            }
        }
    };
    StickyDirective.prototype._render = function () {
        if (!this._destroyed && this._stickyElement) {
            // console.log(`[${this.stickyId}] - _render`);
            if (this._stickyTop !== null
                && this._stickyOffset != null) {
                var scroll_1 = window.pageYOffset;
                if (scroll_1 > this.lastScroll && !this.isSticky && this._stickyElement.getBoundingClientRect()['top'] <= this._stickyTop) {
                    // console.log(`[${this.stickyId}] - _render (set sticky mode)`);
                    this.setSticky();
                }
                else if (scroll_1 < this.lastScroll && this.isSticky && scroll_1 <= this._stickyOffset) {
                    // console.log(`[${this.stickyId}] - _render (unset sticky mode)`);
                    this.unsetSticky();
                }
                else {
                    if (this.isSticky && scroll_1 === this.lastScroll) {
                        this.setStyle('top', this._stickyTop + 'px');
                        // console.log(`[${this.stickyId}] - _render (update sitcky values) - TODO!!!!!!`);
                    }
                }
                this.lastScroll = scroll_1;
            }
        }
    };
    StickyDirective.prototype.setSticky = function () {
        if (!this.isSticky) {
            this.isSticky = true;
            // console.log(`[${this.stickyId}] - top = ${this._stickyElement.clientTop}`);
            this.originalCss = {
                position: this._stickyElement.style.position,
                top: this._stickyElement.clientTop,
                marginTop: this._stickyElement.style.marginTop,
                left: this._stickyElement.clientLeft
            };
            this.setStyle('position', 'fixed');
            this.setStyle('top', this._stickyTop + 'px');
            if (this.appendTo) {
                this.setStyle('left', this.appendTo.getBoundingClientRect()['left'] + 'px');
            }
            this.setClass(true);
            this.onStickyEvent.emit();
            this._onSticky();
        }
    };
    StickyDirective.prototype._onSticky = function () {
        var _this = this;
        setTimeout(function () { _this.update(); }, 0);
    };
    StickyDirective.prototype.unsetSticky = function () {
        if (this.isSticky) {
            this.isSticky = false;
            this.setStyle('position', this.originalCss.position);
            this.setStyle('marginTop', this.originalCss.marginTop);
            this.setStyle('top', this.originalCss.top + 'px');
            if (this.appendTo) {
                this.setStyle('left', this.originalCss.left + 'px');
            }
            this.setClass(false);
            this.onUnStickyEvent.emit();
            this._onUnsetSticky();
        }
    };
    StickyDirective.prototype._onUnsetSticky = function () {
        var _this = this;
        setTimeout(function () { _this.update(); }, 0);
    };
    StickyDirective.prototype.onResize = function () { };
    ; // used by primeng directive to update table layout
    StickyDirective.prototype.setStyle = function (key, value) {
        this.renderer.setStyle(this._stickyElement, key, value);
    };
    StickyDirective.prototype.setClass = function (add) {
        if (add) {
            this.renderer.addClass(this._stickyElement, this.stickyClass);
        }
        else {
            this.renderer.removeClass(this._stickyElement, this.stickyClass);
        }
    };
    StickyDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: StickyScrollService }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], StickyDirective.prototype, "onStickyEvent", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], StickyDirective.prototype, "onUnStickyEvent", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StickyDirective.prototype, "stickyClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], StickyDirective.prototype, "scrollOffset", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], StickyDirective.prototype, "appendTo", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StickyDirective.prototype, "stickyId", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StickyDirective.prototype, "sticksTo", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StickyDirective.prototype, "elementSelector", void 0);
    StickyDirective = __decorate([
        Directive({
            selector: '[kSticky]'
        }),
        __metadata("design:paramtypes", [ElementRef, Renderer2, StickyScrollService])
    ], StickyDirective);
    return StickyDirective;
}());

var StickyComponent = /** @class */ (function () {
    function StickyComponent(_stickyScrollService, _renderer) {
        this._stickyScrollService = _stickyScrollService;
        this._renderer = _renderer;
        this.wrapperHeight = 0;
        this.scrollOffset = 0;
    }
    StickyComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        setTimeout(function () {
            _this._updateLayout();
        }, 0);
        this._stickyScrollService.resizeStatus$.pipe(cancelOnDestroy(this)).subscribe(function (event) {
            _this._updateDimensions();
        });
    };
    StickyComponent.prototype._updateLayout = function () {
        if (this.content.nativeElement.children.length > 0) {
            this.wrapperHeight = this.content.nativeElement.children[0].clientHeight;
        }
        else {
            console.warn("Sticky component::could not access content.");
        }
    };
    StickyComponent.prototype.updateLayout = function (manual) {
        var _this = this;
        if (manual === void 0) { manual = true; }
        setTimeout(function () {
            _this._updateLayout();
            _this._sticky.update();
        }, 0);
    };
    StickyComponent.prototype._updateDimensions = function () {
        this._renderer.setStyle(this.stickyDiv.nativeElement, 'width', this.content.nativeElement.offsetWidth + "px");
    };
    StickyComponent.prototype.ngOnDestroy = function () {
    };
    StickyComponent.ctorParameters = function () { return [
        { type: StickyScrollService },
        { type: Renderer2 }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], StickyComponent.prototype, "scrollOffset", void 0);
    __decorate([
        Input('stickyClass'),
        __metadata("design:type", String)
    ], StickyComponent.prototype, "stickyClass", void 0);
    __decorate([
        Input('container'),
        __metadata("design:type", Object)
    ], StickyComponent.prototype, "container", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StickyComponent.prototype, "stickyId", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], StickyComponent.prototype, "sticksTo", void 0);
    __decorate([
        ViewChild('contentWrapper', { static: true }),
        __metadata("design:type", ElementRef)
    ], StickyComponent.prototype, "content", void 0);
    __decorate([
        ViewChild('stickyDiv', { static: true }),
        __metadata("design:type", ElementRef)
    ], StickyComponent.prototype, "stickyDiv", void 0);
    __decorate([
        ViewChild(StickyDirective, { static: true }),
        __metadata("design:type", StickyDirective)
    ], StickyComponent.prototype, "_sticky", void 0);
    StickyComponent = __decorate([
        Component({
            selector: 'kSticky',
            template: "<div class=\"kStickyWrapper\" [style.height]=\"wrapperHeight + 'px'\" #contentWrapper>\n    <div #stickyDiv class=\"kSticky\" kSticky [scrollOffset]=\"scrollOffset\" [sticksTo]=\"sticksTo\" [stickyClass]=\"stickyClass\" [stickyId]=\"stickyId\" (onStickyEvent)=\"_updateDimensions()\" (onUnStickyEvent)=\"_updateDimensions()\">\n        <ng-content></ng-content>\n    </div>\n</div>\n",
            styles: [".kStickyWrapper{display:block}.kStickyWrapper .kSticky{z-index:501}"]
        }),
        __metadata("design:paramtypes", [StickyScrollService, Renderer2])
    ], StickyComponent);
    return StickyComponent;
}());

var StickyModule = /** @class */ (function () {
    function StickyModule() {
    }
    StickyModule_1 = StickyModule;
    StickyModule.forRoot = function () {
        return {
            ngModule: StickyModule_1,
            providers: [
                StickyScrollService
            ]
        };
    };
    var StickyModule_1;
    StickyModule = StickyModule_1 = __decorate([
        NgModule({
            imports: [
                KalturaCommonModule
            ],
            declarations: [
                StickyComponent,
                StickyDirective
            ],
            exports: [
                StickyComponent,
                StickyDirective
            ],
            providers: []
        })
    ], StickyModule);
    return StickyModule;
}());

var TagComponent = /** @class */ (function () {
    function TagComponent() {
        this.showRemove = true;
        this.onRemoved = new EventEmitter();
    }
    TagComponent.prototype.removeTag = function (tag) {
        this.onRemoved.emit(tag);
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TagComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TagComponent.prototype, "tooltip", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TagComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TagComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TagComponent.prototype, "showRemove", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TemplateRef)
    ], TagComponent.prototype, "template", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TagComponent.prototype, "onRemoved", void 0);
    TagComponent = __decorate([
        Component({
            selector: 'kTag',
            template: "<div class=\"kTag\" [class.kTagDisabled]=\"disabled\" *ngIf=\"label\" [ngSwitch]=\"!!template\">\n\t<div *ngSwitchCase=\"true\">\n\t\t<!-- CUSTOM TEMPLATE -->\n\t\t<ng-container *ngTemplateOutlet=\"template;context:{item: { label: label, tooltip: tooltip, showRemove: showRemove, data: data }}\"></ng-container>\n\t</div>\n    <div class=\"kTagContent\" title=\"{{tooltip}}\" *ngSwitchCase=\"false\">\n        <span class=\"kTagLabel\">{{label}}</span>\n        <i *ngIf=\"showRemove\" class=\"kTagRemove kIconclose_small\" (click)=\"!disabled && removeTag(data)\"></i>\n    </div>\n</div>\n",
            styles: [":host{display:table-cell}.kTag{display:table-cell;height:24px;background-color:#00a784;border-radius:3px;color:#fff;font-size:14px;font-weight:700;padding-left:8px;padding-right:2px}.kTag.kTagDisabled,.kTag.kTagDisabled:hover{background-color:transparent;color:#ccc;border:1px solid #ccc;border-radius:3px}.kTagContent{display:flex;align-items:center}.kTagLabel{flex:0 0 auto;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.kTagRemove{flex:0 0 auto;margin-top:2px;margin-left:8px;padding:5px;cursor:pointer;font-size:10px}.kTagRemove:hover{background-color:rgba(255,255,255,.3);border:0 solid rgba(255,255,255,.3);border-radius:3px}"]
        }),
        __metadata("design:paramtypes", [])
    ], TagComponent);
    return TagComponent;
}());

var $ = $NS;
var TagsComponent = /** @class */ (function () {
    function TagsComponent() {
        this.disabled = false;
        this.removableTags = true;
        this.showClear = true;
        this.clearAllLabel = "Clear All";
        this.onTagRemove = new EventEmitter();
        this.onRemoveAll = new EventEmitter();
        this.onTagsChange = new EventEmitter();
        this._showMore = false;
        this._scrollLeftEnabled = false;
        this._scrollRightEnabled = true;
    }
    TagsComponent.prototype.onWindowResize = function () {
        this.checkShowMore();
    };
    TagsComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (changes['data']) {
            if (this.disabledField && Array.isArray(this.data)) {
                this.data.sort(function (a, b) { return Number(b[_this.disabledField] || 0) - Number(a[_this.disabledField] || 0); });
            }
            this.checkShowMore();
        }
    };
    TagsComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.tagsListObserver = this.tagsList.changes.subscribe(function (comps) {
            _this.onTagsChange.emit({ tagsCount: (_this.data ? _this.data.length : 0) });
            _this.checkShowMore();
        });
    };
    TagsComponent.prototype.ngOnDestroy = function () {
        if (this.tagsListObserver) {
            this.tagsListObserver.unsubscribe();
            this.tagsListObserver = null;
        }
    };
    TagsComponent.prototype.removeTag = function (tag) {
        this.onTagRemove.emit(tag);
    };
    TagsComponent.prototype.clearAll = function () {
        this.onRemoveAll.emit();
    };
    TagsComponent.prototype.checkShowMore = function () {
        var _this = this;
        // we use a cancelable interval to improve performances on window resize
        if (this.showMoreCheckIntervalID) {
            clearInterval(this.showMoreCheckIntervalID);
            this.showMoreCheckIntervalID = null;
        }
        this.showMoreCheckIntervalID = setTimeout(function () {
            if (_this.data && _this.data.length && _this.scroller) {
                _this._showMore = _this.scroller.nativeElement.scrollWidth > (_this.scroller.nativeElement.getBoundingClientRect().width + 1);
            }
            _this.showMoreCheckIntervalID = null;
        }, 100);
    };
    TagsComponent.prototype.scroll = function (direction) {
        var _this = this;
        var scrollPageWidth = this.scroller.nativeElement.getBoundingClientRect().width;
        var totalScroll = this.scroller.nativeElement.scrollWidth;
        if (direction === "right") {
            var targetScrollLeft = this.scroller.nativeElement.scrollLeft + scrollPageWidth;
            $(this.scroller.nativeElement).animate({ scrollLeft: targetScrollLeft }, 800, function () {
                _this._scrollLeftEnabled = true;
                if ((_this.scroller.nativeElement.scrollLeft + scrollPageWidth) >= (totalScroll - 1)) {
                    _this._scrollRightEnabled = false;
                }
            });
        }
        else {
            var targetScrollLeft = this.scroller.nativeElement.scrollLeft - scrollPageWidth;
            $(this.scroller.nativeElement).animate({ scrollLeft: targetScrollLeft }, 800, function () {
                _this._scrollRightEnabled = true;
                if (_this.scroller.nativeElement.scrollLeft <= 1) {
                    _this._scrollLeftEnabled = false;
                }
            });
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], TagsComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TagsComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TagsComponent.prototype, "labelField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TagsComponent.prototype, "tooltipField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TagsComponent.prototype, "disabledField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TagsComponent.prototype, "removableTags", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TagsComponent.prototype, "showClear", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TagsComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TagsComponent.prototype, "clearAllLabel", void 0);
    __decorate([
        ContentChildren(TemplateRef, { descendants: false }),
        __metadata("design:type", QueryList)
    ], TagsComponent.prototype, "templates", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TagsComponent.prototype, "onTagRemove", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TagsComponent.prototype, "onRemoveAll", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TagsComponent.prototype, "onTagsChange", void 0);
    __decorate([
        ViewChild('scroller', { static: false }),
        __metadata("design:type", ElementRef)
    ], TagsComponent.prototype, "scroller", void 0);
    __decorate([
        ViewChildren(TagComponent),
        __metadata("design:type", QueryList)
    ], TagsComponent.prototype, "tagsList", void 0);
    __decorate([
        HostListener("window:resize", []),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TagsComponent.prototype, "onWindowResize", null);
    TagsComponent = __decorate([
        Component({
            selector: 'kTags',
            template: "<div class=\"kTags\" *ngIf=\"data?.length\">\n    <span *ngIf=\"title\" class=\"kTagsTitle\">{{title}}</span>\n    <div #scroller class=\"kScroller\">\n        <div class=\"kTagsWrapper\">\n            <kTag *ngFor=\"let tag of data\"\n                  [data]=\"tag\"\n                  [template]=\"templates ? templates.first : undefined\"\n                  [showRemove]=\"removableTags\"\n                  [label]=\"labelField ? tag[labelField] : tag\"\n                  [tooltip]=\"tooltipField ? tag[tooltipField] : tag\"\n                  [disabled]=\"disabledField ? tag[disabledField] : false\"\n                  (onRemoved)=\"removeTag($event)\"></kTag>\n        </div>\n    </div>\n    <div class=\"kTagsMore\">\n        <div class=\"kScrollArrows\" [style.visibility]=\"_showMore ? 'visible' : 'hidden'\">\n            <i class=\"kIcondropdown_arrow_left kScrollArrow\" [class.disable]=\"!_scrollLeftEnabled\" (click)=\"scroll('left')\"></i>\n            <i class=\"kIcondropdown_arrow_right kScrollArrow\" [class.disable]=\"!_scrollRightEnabled\" (click)=\"scroll('right')\"></i>\n        </div>\n        <span *ngIf=\"showClear\" class=\"kTagsClear\" (click)=\"clearAll()\">{{clearAllLabel}}</span>\n    </div>\n\n</div>\n",
            styles: [":host{width:100%}.kTags{width:100%;height:40px;background-color:#fff;display:flex;flex-wrap:nowrap;-webkit-overflow-scrolling:touch;-ms-overflow-style:-ms-autohiding-scrollbar;align-items:center;border-top:1px solid #dadada;-ms-scroll-limit:0;overflow:hidden;-ms-overflow-style:none}.kTagsTitle{flex:0 0 auto;font-size:15px;color:#333;font-weight:700;margin-left:16px;margin-right:16px}.kTagsClear{margin-left:8px;margin-right:16px;flex-shrink:0;color:#333;font-size:15px;text-decoration:underline;cursor:pointer}.kTagsClear:hover{color:#00a784}.kMoreTagsBtn{flex-shrink:0}.kScroller{width:100%;overflow:hidden}.kTagsMore{align-items:center;display:flex;flex:0 0 auto;margin-left:8px}.kTagsWrapper{display:table;white-space:nowrap;border-collapse:separate;border-spacing:4px}.kScrollArrows{display:flex}.kScrollArrow{width:16px;margin-left:8px;margin-right:8px;cursor:pointer;color:#666}.kScrollArrow:hover{color:#333}.kScrollArrow.disable{cursor:auto;color:#ebebeb;pointer-events:none}.kScrollArrow.disable:hover{color:#ebebeb}"]
        }),
        __metadata("design:paramtypes", [])
    ], TagsComponent);
    return TagsComponent;
}());

var TagsModule = /** @class */ (function () {
    function TagsModule() {
    }
    TagsModule = __decorate([
        NgModule({
            imports: [
                CommonModule
            ],
            declarations: [
                TagsComponent,
                TagComponent
            ],
            exports: [
                TagsComponent,
                TagComponent
            ],
            providers: []
        })
    ], TagsModule);
    return TagsModule;
}());

// accepts http/https/ftp
var urlRegex = new RegExp("(ftp|https?):\\/\\/(www\\.)?[-a-zA-Z0-9^@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9^@:%_\\+.~#?&//=]*)", "i");
// accepts http/https
var urlHttpRegex = new RegExp("(https?):\\/\\/(www\\.)?[-a-zA-Z0-9^@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9^@:%_\\+.~#?&//=]*)", "i");
var ipRegex = new RegExp("^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$", "i");
/**
 * Provides a set of validators used by form controls.
 *
 * A validator is a function that processes a {@link FormControl} or collection of
 * controls and returns a map of errors. A null map means that validation has passed.
 *
 * ### Example
 *
 * ```typescript
 * var loginControl = new FormControl("", [Validators.ip, Validators.required])
 * ```
 *
 */
var KalturaValidators = /** @class */ (function () {
    function KalturaValidators() {
    }
    /**
     * Validator that requires controls to have a value represented as IP (value not required).
     */
    KalturaValidators.ip = function (control) {
        if (!control.value || !control.value.length)
            return null;
        return ipRegex.test(control.value) ? null : { 'ip': true };
    };
    /**
     * Validator that requires controls to have a value represented as URL (value not required).
     */
    KalturaValidators.url = function (control) {
        if (!control.value || !control.value.length)
            return null;
        return urlRegex.test(control.value) ? null : { 'url': true };
    };
    /**
     * Validator that requires controls to have a value represented as URL (value not required).
     */
    KalturaValidators.urlHttp = function (control) {
        if (!control.value || !control.value.length)
            return null;
        return urlHttpRegex.test(control.value) ? null : { 'url': true };
    };
    /**
     * Url validation
     */
    KalturaValidators.isUrlValid = function (url) {
        return urlRegex.test(url);
    };
    return KalturaValidators;
}());

var OnDataSavingReasons;
(function (OnDataSavingReasons) {
    OnDataSavingReasons[OnDataSavingReasons["attachedWidgetBusy"] = 0] = "attachedWidgetBusy";
    OnDataSavingReasons[OnDataSavingReasons["validationErrors"] = 1] = "validationErrors";
    OnDataSavingReasons[OnDataSavingReasons["buildRequestFailure"] = 2] = "buildRequestFailure";
})(OnDataSavingReasons || (OnDataSavingReasons = {}));
var WidgetsManagerBase = /** @class */ (function () {
    function WidgetsManagerBase(logger) {
        this._widgets = [];
        this._widgetsState = new BehaviorSubject({});
        this._isNewData = false;
        this.widgetsState$ = this._widgetsState.asObservable();
        this._logger = logger ? logger.subLogger("widgetsManager") : new EmptyLogger();
    }
    Object.defineProperty(WidgetsManagerBase.prototype, "widgetsState", {
        get: function () {
            return this._widgetsState.getValue();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WidgetsManagerBase.prototype, "isNewData", {
        get: function () {
            return this._isNewData;
        },
        enumerable: true,
        configurable: true
    });
    WidgetsManagerBase.prototype._updateWidgetState = function (newWidgetState) {
        var currentWidgetsState = this._widgetsState.getValue();
        if (!newWidgetState || !newWidgetState.key) {
            this._logger.warn('[widgets manager] cannot update widget state, missing widget key');
        }
        else {
            this._logger.info("[widgets manager] widget '" + newWidgetState.key + "': update widget state", newWidgetState);
            currentWidgetsState[newWidgetState.key] = newWidgetState;
            this._widgetsState.next(currentWidgetsState);
        }
    };
    WidgetsManagerBase.prototype.registerWidgets = function (widgets) {
        var _this = this;
        if (widgets) {
            widgets.forEach(function (widget) {
                var existingRegisteredWidget = _this._widgets.find(function (registeredWidget) { return registeredWidget === widget || registeredWidget.key === widget.key; });
                if (existingRegisteredWidget) {
                    throw new Error("a widget with key '" + widget.key + "' is already registered (did you registered the same widget twice?)");
                }
                else {
                    _this._logger.info("[widgets manager] widget '" + widget.key + "': registered to a form widgets manager");
                    widget._setForm(_this);
                    _this._widgets.push(widget);
                }
            });
        }
    };
    WidgetsManagerBase.prototype.notifyDataLoading = function (dataId) {
        this._logger.info("[widgets manager] notify data loading. data identifier '" + dataId + "'");
        this._widgets.filter(function (widget) { return widget.isActive; }).forEach(function (widget) {
            widget._reset();
        });
        this._widgets.forEach(function (widget) {
            widget._handleDataLoading(dataId);
        });
    };
    WidgetsManagerBase.prototype.notifyDataLoaded = function (data, settings) {
        this._logger.info("[widgets manager] notify data loaded.");
        var errors = [];
        this._isNewData = settings.isNewData;
        this._logger.info("[widgets manager] treat data as '" + (this._isNewData ? 'new' : 'existing') + " data'.");
        this._widgets.forEach(function (widget) {
            try {
                widget._handleDataLoaded(data);
                widget.activate();
            }
            catch (e) {
                errors.push(e);
            }
        });
        return { errors: errors };
    };
    WidgetsManagerBase.prototype._widgetsOnDataSaving = function (newData, request, originalData) {
        var _this = this;
        var errors = [];
        var widgets = this._isNewData ? this._widgets : this._widgets.filter(function (widget) { return widget.isActive; });
        widgets.forEach(function (widget) {
            try {
                _this._logger.info("[widgets manager] widget '" + widget.key + "': build save request content");
                widget._handleDataSaving(newData, request, originalData);
            }
            catch (err) {
                _this._logger.error("[widgets manager] widget '" + widget.key + "': failed to prepare data for save. Save operation aborted.", err); // keep error
                errors.push(err);
            }
        });
        return { errors: errors };
    };
    WidgetsManagerBase.prototype.notifyDataSaving = function (newData, request, originalData) {
        var _this = this;
        this._logger.info("[widgets manager] notify data saving.");
        var isAttachedWidgetBusy = !!this._widgets.find(function (widget) { return widget.isAttached && widget.isBusy; });
        return Observable.of(isAttachedWidgetBusy ?
            {
                ready: false,
                reason: OnDataSavingReasons.attachedWidgetBusy
            } : { ready: true })
            .pipe(cancelOnDestroy(this))
            .flatMap(function (response) {
            if (response.ready) {
                return _this._validateWidgets()
                    .catch(function (error, caught) { return Observable.of({ isValid: false }); })
                    .map(function (response) { return response.isValid ? { ready: true } : {
                    ready: false,
                    reason: OnDataSavingReasons.validationErrors
                }; });
            }
            else {
                return Observable.of(response);
            }
        })
            .map(function (response) {
            if (response.ready) {
                var saveContent = _this._widgetsOnDataSaving(newData, request, originalData);
                if (saveContent.errors.length === 0) {
                    return { ready: true, reason: null };
                }
                else {
                    return {
                        ready: false,
                        reason: OnDataSavingReasons.buildRequestFailure,
                        errors: saveContent.errors
                    };
                }
            }
            else {
                return response;
            }
        });
    };
    WidgetsManagerBase.prototype._validateWidgets = function () {
        var _this = this;
        var widgets = this._isNewData ? this._widgets : this._widgets.filter(function (widget) { return widget.isActive; });
        var widgetsResults = widgets.map(function (widget) {
            return widget._validate()
                .pipe(cancelOnDestroy(_this))
                .catch(function (err, caught) { return Observable.of({ isValid: false }); });
        });
        if (widgetsResults.length) {
            return Observable.forkJoin.apply(Observable, __spread(widgetsResults)).map(function (responses) {
                return responses.find(function (response) { return !response.isValid; }) || { isValid: true };
            });
        }
        else {
            return Observable.of({ isValid: true });
        }
    };
    WidgetsManagerBase.prototype.ngOnDestroy = function () {
        this._widgets.forEach(function (widget) {
            widget.destory();
        });
        this._logger.warn('[widgets manager] form widgets manager ngOnDestroy');
        this._widgetsState.complete();
    };
    return WidgetsManagerBase;
}());

// DEVELOPER NOTE: Don't implement ngOnDestroy - the inheritor will probably override this without calling super()
var WidgetBase = /** @class */ (function () {
    function WidgetBase(_key, logger) {
        this._key = _key;
        // DEVELOPER NOTE: this class cannot use 'cancelOnDestroy' operation
        // because it must assume the inheriter will override it
        this._activateSubscription = null;
        this._dataSource = new ReplaySubject(1);
        this.data$ = this._dataSource.asObservable();
        this._widgetState = { key: this.key, isValid: true, isDirty: false, isAttached: false, isBusy: false, isActive: false, wasActivated: false };
        this._widgetReset = new Subject();
        this.widgetReset$ = this._widgetReset.asObservable();
        if (!_key) {
            throw new Error("Form widget key is required when constructing widget of type '" + typeof this);
        }
        this._logger = logger ? logger.subLogger("widgets." + _key) : new EmptyLogger();
    }
    Object.defineProperty(WidgetBase.prototype, "data", {
        get: function () {
            return this._data;
        },
        enumerable: true,
        configurable: true
    });
    WidgetBase.prototype.onDataSaving = function (newData, request, originalData) {
    };
    Object.defineProperty(WidgetBase.prototype, "wasActivated", {
        get: function () {
            return this._widgetState.wasActivated;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WidgetBase.prototype, "isValid", {
        get: function () {
            return this._widgetState.isValid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WidgetBase.prototype, "isDirty", {
        get: function () {
            return this._widgetState.isDirty;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WidgetBase.prototype, "isActive", {
        get: function () {
            return this._widgetState.isActive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WidgetBase.prototype, "isAttached", {
        get: function () {
            return this._widgetState.isAttached;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WidgetBase.prototype, "isBusy", {
        get: function () {
            return this._widgetState.isBusy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WidgetBase.prototype, "key", {
        get: function () {
            return this._key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WidgetBase.prototype, "isNewData", {
        get: function () {
            return this.form.isNewData;
        },
        enumerable: true,
        configurable: true
    });
    WidgetBase.prototype.onValidate = function (wasActivated) {
        return Observable.of({ isValid: true });
    };
    WidgetBase.prototype.updateState = function (stateUpdate) {
        this._updateState(stateUpdate);
    };
    WidgetBase.prototype._updateState = function (stateUpdate) {
        var _this = this;
        this._verifyRegistered();
        var stateHasChanges = Object.keys(stateUpdate).reduce(function (result, propertyName) { return result || _this._widgetState[propertyName] !== stateUpdate[propertyName]; }, false);
        if (stateHasChanges) {
            Object.assign(this._widgetState, stateUpdate);
            if (this.form) {
                var newWidgetState = Object.assign({}, this._widgetState);
                this.form._updateWidgetState(newWidgetState);
            }
        }
    };
    WidgetBase.prototype.onDataLoaded = function (data) {
    };
    WidgetBase.prototype.onDataLoading = function (dataId) {
    };
    WidgetBase.prototype.onActivate = function (firstTimeActivating) {
    };
    WidgetBase.prototype._setForm = function (manager) {
        this.form = manager;
    };
    WidgetBase.prototype._handleDataLoading = function (dataId) {
        this._verifyRegistered();
        this._setData(null);
        this.onDataLoading(dataId);
    };
    WidgetBase.prototype._setData = function (data) {
        this._data = data;
        this._dataSource.next(data);
    };
    WidgetBase.prototype._handleDataLoaded = function (data) {
        this._verifyRegistered();
        this._setData(data);
        this.onDataLoaded(data);
    };
    WidgetBase.prototype._validate = function () {
        var _this = this;
        this._verifyRegistered();
        return this.onValidate(this.wasActivated)
            .do(function (response) {
            var updateState = (response.isValid !== _this._widgetState.isValid);
            if (updateState) {
                _this._logger.info("[widget] widget '" + _this.key + "': widget 'isValid' state doesn't match result of 'onValidate'. updating status to '" + (response.isValid ? 'valid' : 'invalid') + "'");
                _this.updateState({ isValid: response.isValid });
            }
        });
    };
    WidgetBase.prototype._handleDataSaving = function (newData, request, originalData) {
        this._verifyRegistered();
        this.onDataSaving(newData, request, originalData);
    };
    WidgetBase.prototype._reset = function () {
        this._verifyRegistered();
        this._logger.info("[widget] widget '" + this.key + "': reset widget");
        if (this._activateSubscription) {
            this._activateSubscription.unsubscribe();
            this._activateSubscription = null;
        }
        this._widgetReset.next('');
        this._updateState({ isValid: true, isDirty: false, isActive: false, isBusy: false });
        this.onReset();
    };
    WidgetBase.prototype._verifyRegistered = function () {
        if (!this.form) {
            this._logger.error("[widget] widget '" + this.key + "': cannot perform action, widget is not registered to a manager (did you forgot to register it in the main route component?)");
            throw new Error("[widget] cannot perform action. widget with key ''" + this.key + "'' is not registered to a manager");
        }
    };
    WidgetBase.prototype.activate = function () {
        var _this = this;
        this._verifyRegistered();
        if (this.data && this.isAttached && !this.isActive) {
            this._reset();
            var previousStatus_1 = {
                wasActivated: this.wasActivated
            };
            this._logger.info("[widget] widget '" + this.key + "': activating widget (first time = " + !previousStatus_1.wasActivated + ")");
            var activate$ = this.onActivate(!this.wasActivated);
            this._updateState({ isActive: true, wasActivated: true });
            if (activate$ instanceof Observable) {
                this._logger.info("[widget] widget '" + this.key + "': widget requested for async activation operation. executing async operation.");
                this._activateSubscription = activate$
                    .catch(function (error, caught) { return Observable.of({ failed: true, error: error }); })
                    .subscribe(function (response) {
                    if (response && response.failed) {
                        _this._logger.info("[widget] widget '" + _this.key + "': async widget activation failed. revert state to " + JSON.stringify(previousStatus_1) + ")");
                        _this._updateState({ isActive: false, wasActivated: previousStatus_1.wasActivated });
                    }
                    else {
                        _this._logger.info("[widget] widget '" + _this.key + "': async widget activation completed");
                    }
                }, function () {
                    _this._activateSubscription = null;
                }, function () {
                    _this._activateSubscription = null;
                });
            }
        }
    };
    WidgetBase.prototype.attachForm = function () {
        this._verifyRegistered();
        if (this.isAttached) {
            this._logger.warn("[widget] widget with key '" + this.key + "' is already attached (did you attached two components to the same widget? did you forgot to detach the widget upon ngOnDestroy?)");
        }
        else {
            this._logger.info("[widget] widget '" + this.key + "': attaching widget");
            this._updateState({ isAttached: true });
            this.activate();
        }
    };
    WidgetBase.prototype.detachForm = function () {
        this._verifyRegistered();
        if (!this.isAttached) {
            this._logger.warn("[widget] widget with key '" + this.key + "' is already detached (did you attached two components to the same widget? did you forgot to attach the widget upon ngOnInit?)");
        }
        else {
            this._logger.info("[widget] widget '" + this.key + "': detaching widget");
            this._updateState({ isAttached: false });
        }
    };
    WidgetBase.prototype.destory = function () {
        this._reset();
        this._widgetReset.complete();
    };
    return WidgetBase;
}());

var FileDialogComponent = /** @class */ (function () {
    function FileDialogComponent(elementRef) {
        this.elementRef = elementRef;
        this.filter = "";
        this.allowMultiple = false;
        this.onFileSelected = new EventEmitter();
    }
    FileDialogComponent.prototype.open = function (event) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        this.elementRef.nativeElement.firstElementChild.value = "";
        this.elementRef.nativeElement.firstElementChild.click();
    };
    FileDialogComponent.prototype._fileInputChange = function (event) {
        if (event.currentTarget.files && event.currentTarget.files.length) {
            this.onFileSelected.emit(event.currentTarget.files);
        }
    };
    FileDialogComponent.prototype.ngOnInit = function () {
    };
    FileDialogComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], FileDialogComponent.prototype, "filter", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], FileDialogComponent.prototype, "allowMultiple", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], FileDialogComponent.prototype, "onFileSelected", void 0);
    FileDialogComponent = __decorate([
        Component({
            selector: 'kFileDialog',
            template: "<input tabindex=\"-1\" [attr.multiple]=\"allowMultiple ? true : null\" type=\"file\" accept=\"{{filter}}\" (change)=\"_fileInputChange($event)\"/>\n",
            styles: ["input{position:fixed;left:-1000px;top:-1000px}"]
        }),
        __metadata("design:paramtypes", [ElementRef])
    ], FileDialogComponent);
    return FileDialogComponent;
}());

var moment = momentNS;
var DatePipe = /** @class */ (function () {
    function DatePipe() {
    }
    DatePipe.prototype.transform = function (date, format) {
        if (date) {
            if (!format) {
                format = "dateAndTime";
            }
            switch (format) {
                case 'dateOnly':
                    format = 'MM/DD/YY';
                    break;
                case 'timeOnly':
                    format = 'HH:mm';
                    break;
                case 'dateAndTime':
                    format = "MM/DD/YY HH:mm";
                    break;
                case 'longDateOnly':
                    format = "MMMM D, YYYY";
                    break;
                default:
                    break;
            }
            return moment(date).format(format);
        }
        else {
            return '';
        }
    };
    DatePipe = __decorate([
        Pipe({
            name: 'kDate'
        }),
        __metadata("design:paramtypes", [])
    ], DatePipe);
    return DatePipe;
}());

/*
 * Convert bytes into largest possible unit.
 * Takes an precision argument that defaults to 2.
 * Usage:
 *   bytes | fileSize:precision
 * Example:
 *   {{ 1024 |  fileSize}}
 *   formats to: 1 KB
 */
var FileSizePipe = /** @class */ (function () {
    function FileSizePipe() {
        this.units = [
            'bytes',
            'KB',
            'MB',
            'GB',
            'TB',
            'PB'
        ];
    }
    FileSizePipe.prototype.transform = function (bytes, precision) {
        if (bytes === void 0) { bytes = 0; }
        if (precision === void 0) { precision = 2; }
        if (isNaN(parseFloat(String(bytes))) || !isFinite(bytes))
            return 'N/A';
        var unit = 0;
        while (bytes >= 1024) {
            bytes /= 1024;
            unit++;
        }
        return bytes.toFixed(+precision) + ' ' + this.units[unit];
    };
    FileSizePipe = __decorate([
        Pipe({ name: 'kFileSize' })
    ], FileSizePipe);
    return FileSizePipe;
}());

var AutofocusDirective = /** @class */ (function () {
    function AutofocusDirective(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this._autofocus = true;
    }
    AutofocusDirective.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (this._autofocus) {
            setTimeout(function () {
                _this.renderer.selectRootElement(_this.el.nativeElement).focus();
            });
        }
    };
    Object.defineProperty(AutofocusDirective.prototype, "inputAutofocus", {
        set: function (allowed) {
            this._autofocus = allowed;
        },
        enumerable: true,
        configurable: true
    });
    AutofocusDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], AutofocusDirective.prototype, "inputAutofocus", null);
    AutofocusDirective = __decorate([
        Directive({
            selector: '[kAutofocus]'
        }),
        __metadata("design:paramtypes", [ElementRef, Renderer2])
    ], AutofocusDirective);
    return AutofocusDirective;
}());

var BrowserNames;
(function (BrowserNames) {
    BrowserNames[BrowserNames["IE11"] = 0] = "IE11";
    BrowserNames[BrowserNames["other"] = 1] = "other";
})(BrowserNames || (BrowserNames = {}));
var KalturaBrowserUtils = /** @class */ (function () {
    function KalturaBrowserUtils() {
    }
    KalturaBrowserUtils.detectBrowser = function () {
        if (!!window['MSInputMethodContext'] && !!document['documentMode']) {
            return BrowserNames.IE11;
        }
        else {
            return BrowserNames.other;
        }
    };
    return KalturaBrowserUtils;
}());

var SafePipe = /** @class */ (function () {
    function SafePipe(sanitizer) {
        this.sanitizer = sanitizer;
    }
    SafePipe.prototype.transform = function (url) {
        return this.sanitizer.bypassSecurityTrustResourceUrl(url);
    };
    SafePipe.ctorParameters = function () { return [
        { type: DomSanitizer }
    ]; };
    SafePipe = __decorate([
        Pipe({ name: 'safe' }),
        __metadata("design:paramtypes", [DomSanitizer])
    ], SafePipe);
    return SafePipe;
}());

var TimePipe = /** @class */ (function () {
    function TimePipe() {
    }
    TimePipe.prototype.transform = function (value) {
        if (typeof value === "string") {
            return value;
        }
        else {
            var hours = Math.floor(Math.round(value) / 3600);
            var minutes = Math.floor((Math.round(value) / 60) % 60);
            var seconds = Math.round(value) % 60;
            var hoursStr = hours === 0 ? '' : hours.toString() + ":";
            var minutesStr = minutes === 0 && hours === 0 ? '00' : minutes < 10 ? '0' + minutes.toString() : minutes.toString();
            var secondsStr = seconds < 10 ? '0' + seconds.toString() : seconds.toString();
            return hoursStr + minutesStr + ":" + secondsStr;
        }
    };
    TimePipe = __decorate([
        Pipe({ name: 'kTime' })
    ], TimePipe);
    return TimePipe;
}());

var LineBreakPipe = /** @class */ (function () {
    function LineBreakPipe() {
    }
    LineBreakPipe.prototype.transform = function (str) {
        if (str.split("\r").length > 0 && str.split("\r\n").length < str.split("\r").length) {
            str = str.split("\r").join("\r\n");
        }
        return str;
    };
    LineBreakPipe = __decorate([
        Pipe({
            name: 'kLineBreak'
        }),
        __metadata("design:paramtypes", [])
    ], LineBreakPipe);
    return LineBreakPipe;
}());

var ScrollToTopContainerComponent = /** @class */ (function () {
    function ScrollToTopContainerComponent(_el) {
        this._el = _el;
    }
    ScrollToTopContainerComponent.prototype.scrollToTop = function () {
        this._el.nativeElement.scrollTop = 0;
    };
    ScrollToTopContainerComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    ScrollToTopContainerComponent = __decorate([
        Component({
            selector: 'kScrollToTopContainer',
            template: '<ng-content></ng-content>',
            styles: [':host { display: block }']
        }),
        __metadata("design:paramtypes", [ElementRef])
    ], ScrollToTopContainerComponent);
    return ScrollToTopContainerComponent;
}());

var KalturaUIModule = /** @class */ (function () {
    function KalturaUIModule() {
    }
    KalturaUIModule = __decorate([
        NgModule({
            imports: [
                CommonModule
            ],
            declarations: [
                SafePipe,
                TimePipe,
                FileDialogComponent,
                KalturaPlayerComponent,
                DatePipe,
                FileSizePipe,
                LineBreakPipe,
                AutofocusDirective,
                ScrollToTopContainerComponent,
            ],
            exports: [
                TimePipe,
                SafePipe,
                FileDialogComponent,
                KalturaPlayerComponent,
                DatePipe,
                FileSizePipe,
                LineBreakPipe,
                AutofocusDirective,
                ScrollToTopContainerComponent
            ],
            providers: []
        })
    ], KalturaUIModule);
    return KalturaUIModule;
}());

var InputRangeComponent = /** @class */ (function () {
    function InputRangeComponent() {
        this.pointOvered = [];
        this.onChange = function (value) { };
        this.onTouched = function () { };
    }
    InputRangeComponent_1 = InputRangeComponent;
    InputRangeComponent.prototype.ngOnInit = function () {
        this.selectedOptionIndex = this.options.findIndex(function (option) { return option.isSelected; });
        this.selectedOptionIndex = this.selectedOptionIndex == -1 ? 0 : this.selectedOptionIndex;
        this.selectedText = this.options[this.selectedOptionIndex].label;
    };
    InputRangeComponent.prototype.getProgressBarStyle = function () {
        return 100 / (this.options.length - 1) * (this.selectedOptionIndex >= 0 ? this.selectedOptionIndex : 0);
    };
    InputRangeComponent.prototype.pointSelected = function (index) {
        if (this.selectedOptionIndex > 0) {
            this.options[this.selectedOptionIndex].isSelected = false;
        }
        this.options[index].isSelected = true;
        this.selectedText = this.options[index].label;
        this.selectedOptionIndex = index;
        this.onTouched();
        this.onChange(this.options[index].value);
    };
    //From ControlValueAccessor interface
    InputRangeComponent.prototype.writeValue = function (value) {
        var valueOptionIndex = this.options.findIndex(function (option) { return option.value == value; });
        if (valueOptionIndex !== -1) {
            this.pointSelected(valueOptionIndex);
        }
    };
    //From ControlValueAccessor interface
    InputRangeComponent.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    //From ControlValueAccessor interface
    InputRangeComponent.prototype.registerOnTouched = function (fn) {
        this.onTouched = fn;
    };
    var InputRangeComponent_1;
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], InputRangeComponent.prototype, "options", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], InputRangeComponent.prototype, "width", void 0);
    InputRangeComponent = InputRangeComponent_1 = __decorate([
        Component({
            selector: 'kInputRange',
            template: "<div class=\"kRangeContainer\">\n  <div [style.width]=\"width\">\n    <div class=\"kRangeInput kRangeInputBlock\">\n      <div class=\"kBbar\">\n        <div class=\"kBarProgress\"\n             [style.width]=\"getProgressBarStyle() + '%'\"></div>\n        <div class=\"kBarPoints\">\n          <div class=\"kBarPointCol\" (mouseout)=\"pointOvered[i]=false\" (mouseover)=\"pointOvered[i]=true\" [style.width]=\"100 / (options.length-1) + '%'\"\n               *ngFor=\"let option of options; index as i\">\n            <div class=\"kPoint\"\n                 [ngClass]=\"{\n                 'kSelected': (pointOvered.length > 0 && pointOvered[i]) || i == selectedOptionIndex,\n                 'kBgPrimary':  i <= selectedOptionIndex\n               }\"></div>\n            <div class=\"kPointClickArea\"\n                 (click) = \"pointSelected(i)\"\n                 [kTooltip] = \"option.tooltip\"></div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n  <span class=\"kSelectedLabel\">{{selectedText}}</span>\n</div>\n",
            providers: [
                {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: InputRangeComponent_1,
                    multi: true
                }
            ],
            styles: [".kRangeContainer{display:flex}.kRangeContainer .kRangeInput{display:inline-block;padding-top:10px;padding-bottom:50px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.kRangeContainer .kRangeInput.kRangeInputBlock{display:block;width:100%}.kRangeContainer .kRangeInput .kBbar{height:4px;width:100%;background-color:#ccc;position:relative}.kRangeContainer .kRangeInput .kBbar .kBarProgress{background-color:#00a784;height:100%}.kRangeContainer .kRangeInput .kBbar .kBarPoints{position:absolute;left:0;top:-8px;width:100%}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol{float:left;position:relative;height:20px}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol:last-child{width:0%!important}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol .kPointClickArea{position:absolute;width:45px;margin-top:-10px;height:40px;transform:translateX(-50%);cursor:pointer}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol .kPoint{width:9px;height:9px;margin-top:1px;border-radius:50%;background-color:#ccc;position:absolute;transform:translateX(-50%);cursor:pointer;border:4px solid #fff}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol .kPoint.kSelected{width:16px;height:16px;margin-top:-3px;border-radius:50%}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol .kPoint.kBgPrimary{background-color:#00a784}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol .kPoint.kBgPrimary.kSelected{border:none!important;margin-top:2px!important}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol span{position:absolute;transform:translateX(-50%);bottom:-36px;white-space:nowrap}.kRangeContainer .kSelectedLabel{padding-left:30px;padding-top:3px;font-size:15px}"]
        }),
        __metadata("design:paramtypes", [])
    ], InputRangeComponent);
    return InputRangeComponent;
}());

var InputRangeModule = /** @class */ (function () {
    function InputRangeModule() {
    }
    InputRangeModule = __decorate([
        NgModule({
            imports: [
                CommonModule,
                TooltipModule
            ],
            declarations: [
                InputRangeComponent
            ],
            exports: [
                InputRangeComponent
            ],
            providers: []
        })
    ], InputRangeModule);
    return InputRangeModule;
}());

/*
 * Public API Surface of kaltura-ui
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AreaBlockerComponent, AreaBlockerMessage, AreaBlockerModule, AutofocusDirective, BrowserNames, DatePickerControl, DatePipe, DetailInfoComponent, DetailsBarComponent, DetailsBarModule, DynamicDropdownControl, DynamicFormControlBase, DynamicFormItem, DynamicFormModule, DynamicFormService, DynamicSectionControl, FileDialogComponent, FileSizePipe, InputHelperComponent, InputHelperModule, InputRangeComponent, InputRangeModule, KTooltipDirective, KalturaBrowserUtils, KalturaPlayerComponent, KalturaUIModule, KalturaValidators, LineBreakPipe, ListControl, NumberControl, OnDataSavingReasons, PopupWidgetComponent, PopupWidgetModule, PopupWidgetStates, SafePipe, ScrollToTopContainerComponent, StickyComponent, StickyDirective, StickyModule, StickyScrollService, SwitchControl, TagComponent, TagsComponent, TagsModule, TextAreaControl, TextboxControl, TimePipe, TooltipModule, WidgetBase, WidgetsManagerBase, ipRegex, urlHttpRegex, urlRegex };
//# sourceMappingURL=kaltura-ng-kaltura-ui.js.map

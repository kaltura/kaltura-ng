import { __decorate, __metadata, __param } from 'tslib';
import { Injectable, Self, Optional, NgModule, InjectionToken, Inject } from '@angular/core';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { Observable, Subject, Subscriber, merge } from 'rxjs';
import 'rxjs/add/operator/groupBy';
import { CommonModule } from '@angular/common';

class OperationTagStoreMediator {
    static register(operationsTagManager) {
        this._operationsTagManager = operationsTagManager;
    }
    static increase(tag) {
        if (this._operationsTagManager) {
            this._operationsTagManager.increase(tag);
        }
    }
    static decrease(tag) {
        if (this._operationsTagManager) {
            this._operationsTagManager.decrease(tag);
        }
    }
}
OperationTagStoreMediator._operationsTagManager = null;

let OperationTagManagerService = class OperationTagManagerService {
    constructor() {
        this._tagStatus = new BehaviorSubject({});
        // whenever a tag status changes this event is emitted
        this.tagStatus$ = this._tagStatus.asObservable();
    }
    // increase the count for a tag
    increase(tag) {
        const tagsData = this._tagStatus.getValue();
        if (!tagsData[tag]) {
            tagsData[tag] = 0;
        }
        tagsData[tag]++;
        this._tagStatus.next(tagsData);
    }
    decrease(tag) {
        const tagsData = this._tagStatus.getValue();
        if (tagsData[tag] > 0) {
            tagsData[tag]--;
            this._tagStatus.next(tagsData);
        }
        else {
            tagsData[tag] = 0;
            this._tagStatus.next(tagsData);
        }
    }
};
OperationTagManagerService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [])
], OperationTagManagerService);

var OperationTagModule_1;
let OperationTagModule = OperationTagModule_1 = class OperationTagModule {
    // Prevents angular from creating another instance for operationTagManagerService when defined as provider in more than one place
    // (Each component will get the same instance as in the module/component that called the operationTagManagerService.forRoot)
    constructor(operationTagManagerService) {
        if (operationTagManagerService) {
            OperationTagStoreMediator.register(operationTagManagerService);
        }
    }
    static forRoot() {
        return {
            ngModule: OperationTagModule_1,
            providers: [
                OperationTagManagerService
            ]
        };
    }
};
OperationTagModule.ctorParameters = () => [
    { type: OperationTagManagerService, decorators: [{ type: Self }, { type: Optional }] }
];
OperationTagModule = OperationTagModule_1 = __decorate([
    NgModule({
        imports: [],
        declarations: [],
        exports: [],
        providers: []
    }),
    __param(0, Self()), __param(0, Optional()),
    __metadata("design:paramtypes", [OperationTagManagerService])
], OperationTagModule);

'use strict';
/**
 * Source - from http://fiznool.com/blog/2014/11/16/short-id-generation-in-javascript/
 */
/**
 * The default alphabet is 25 numbers and lowercase letters.
 * Any numbers that look like letters and vice versa are removed:
 * 1 l, 0 o.
 * Also the following letters are not present, to prevent any
 * expletives: cfhistu
 */
var DEFAULT_ALPHABET = '23456789abdegjkmnpqrvwxyz';
// Governs the length of the ID.
// With an alphabet of 25 chars,
// a length of 8 gives us 25^8 or
// 152,587,890,625 possibilities.
// Should be enough...
var DEFAULT_ID_LENGTH = 5;
/**
 * Governs the number of times we should try to find
 * a unique value before giving up.
 */
var UNIQUE_RETRIES = 9999;
class FriendlyHashId {
    static generate(alphabetOptions) {
        if (!FriendlyHashId.defaultInstance) {
            FriendlyHashId.defaultInstance = new FriendlyHashId();
        }
        return FriendlyHashId.defaultInstance.generate(alphabetOptions);
    }
    /**
     * Returns a randomly-generated friendly ID.
     * Note that the friendly ID is not guaranteed to be
     * unique to any other ID generated by this same method,
     * so it is up to you to check for uniqueness.
     * return {String} friendly ID.
     */
    generate(alphabetOptions) {
        var options = alphabetOptions || {};
        var alphabet = options.alphabet || DEFAULT_ALPHABET;
        var idLength = options.idLength || DEFAULT_ID_LENGTH;
        var rtn = '';
        for (var i = 0; i < idLength; i++) {
            rtn += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
        }
        return rtn;
    }
    ;
    /**
     * Tries to generate a unique ID that is not defined in the
     * `previous` array.
     * param  {Array} previous The list of previous ids to avoid.
     * return {String} A unique ID, or `null` if one could not be generated.
     */
    generateUnique(previous) {
        previous = previous || [];
        var retries = 0;
        var id;
        // Try to generate a unique ID,
        // i.e. one that isn't in the previous.
        while (!id && retries < UNIQUE_RETRIES) {
            id = this.generate();
            if (previous.indexOf(id) !== -1) {
                id = null;
                retries++;
            }
        }
        return id;
    }
    ;
}
FriendlyHashId.defaultInstance = null;

const KalturaLoggerInjectionToken = new InjectionToken('kaltura-logger');
class EmptyLogger {
    trace(message, context) {
    }
    debug(message, context) {
    }
    info(message, context) {
    }
    warn(message, context) {
    }
    error(message, context) {
    }
    fatal(message, context) {
    }
    subLogger(name) {
        return new EmptyLogger();
    }
}

class ServerPolls {
    constructor(kalturaLogger) {
        this._pollQueue = {};
        this._tokenGenerator = new FriendlyHashId();
        this._missingDestoryHandling = false;
        this._subscriptions = [];
        this._state = new BehaviorSubject({ busy: false });
        this.state$ = this._state.asObservable();
        this._queueInterval = null;
        if (kalturaLogger) {
            this._logger = kalturaLogger;
        }
        else {
            this._logger = new EmptyLogger();
        }
        this._initialize();
    }
    _warnAboutMissingDestory() {
        // NOTICE: showing a warning every time since this is an implementation issue that must be addressed during development.
        const error = `calling method '_getOnDestroy$()' didn't return valid observable (did you remember to provide 'Observable' that will be invoked from ngOnDestroy method?)`;
        this._logger.error(error);
    }
    _initialize() {
        this._logger.trace('_initialize()');
        setTimeout(() => {
            const onDestroy$ = this._getOnDestroy$();
            if (!onDestroy$) {
                this._missingDestoryHandling = true;
                this._warnAboutMissingDestory();
            }
            else {
                onDestroy$.subscribe(() => {
                    this._logger.trace('onDestroy$.subscribe()');
                    this._cancelQueueInterval();
                    this._subscriptions.forEach(item => {
                        item.unsubscribe();
                    });
                    this._subscriptions = [];
                });
            }
        });
    }
    _cancelQueueInterval() {
        clearTimeout(this._queueTimeout);
    }
    _getPollQueueList() {
        return Object.keys(this._pollQueue).map(key => this._pollQueue[key]);
    }
    _setupQueueTimer() {
        this._cancelQueueInterval();
        const pollQueueList = this._getPollQueueList();
        if (this._missingDestoryHandling) {
            // NOTICE: showing a warning every time since this is an implementation issue that must be addressed during development.
            this._warnAboutMissingDestory();
        }
        if (!pollQueueList.length) {
            this._logger.info('no actions found in the queue. suspending interval until an action will be added');
            return;
        }
        let newInterval = null;
        const hasNewPolls = pollQueueList.some(({ lastExecution }) => !!lastExecution);
        if (!hasNewPolls) {
            newInterval = Math.min(...pollQueueList.map(({ interval }) => interval)) / 2;
        }
        newInterval = newInterval && newInterval > 10 ? newInterval : 10; // default to ten seconds (minimum value)
        if (this._queueInterval !== newInterval) {
            this._logger.info(`updating queue interval to poll server every ${newInterval} seconds`);
            this._queueInterval = newInterval;
        }
        this._queueTimeout = setTimeout(() => {
            this._onQueueTimerTick();
        }, this._queueInterval * 1000);
    }
    forcePolling() {
        this._logger.info('force server polling requested');
        // cancel active requests
        this._cancelQueueInterval();
        this._subscriptions.forEach(subscription => {
            subscription.unsubscribe();
        });
        this._subscriptions = [];
        // enable all requests
        this._getPollQueueList().forEach(item => item.queryEnabled = true);
        // send poll request for all requests
        const subscription = this._queryPollItems(this._getPollQueueList())
            .subscribe(() => this._setupQueueTimer(), () => this._setupQueueTimer());
    }
    _queryPollItems(items) {
        return Observable.create(observer => {
            this._logger.debug(`execute server polling`);
            if (!this._canExecute() || !items || items.length === 0) {
                this._logger.debug(`execute server polling ignored, cannot execute request or no items provided to query`);
                observer.next(undefined);
                return;
            }
            const requests = items.map(item => {
                let ItemRequest;
                let error;
                try {
                    ItemRequest = item.requestFactory.create();
                }
                catch (err) {
                    this._logger.error(`failed to create a request for '${item.id}'. got the following error : '${err.message}'`);
                    ItemRequest = null;
                    error = this._createGlobalError(err);
                }
                if (error) {
                    this._propagateServerResponse(item, { error: error, result: null });
                }
                return ItemRequest ? { pollItem: item, request: ItemRequest } : null;
            }).filter(Boolean);
            this._logger.info(`executing server poll for ${requests.length} items`);
            if (!requests.length) {
                observer.next(undefined);
            }
            else {
                const subscription = this._executeRequests(requests.map(item => item.request))
                    .subscribe(response => {
                    this._removeSubscription(subscription);
                    this._logger.info(`got ${response.length} responses. propagate responses to relevant actions`);
                    requests.forEach(({ pollItem }, index) => {
                        let result = response[index];
                        if (Array.isArray(result)) {
                            result = { result, error: null };
                        }
                        this._propagateServerResponse(pollItem, result);
                    });
                    observer.next(undefined);
                }, (error) => {
                    this._logger.error(`failed to query the server. got the following error : '${error.message}'`);
                    this._removeSubscription(subscription);
                    const errorResponse = { error: this._createGlobalError(error), result: null };
                    requests.forEach(({ pollItem }) => {
                        this._propagateServerResponse(pollItem, errorResponse);
                    });
                    observer.next(undefined);
                });
                this._subscriptions.push(subscription);
                return () => {
                    this._removeSubscription(subscription);
                };
            }
        });
    }
    _removeSubscription(subscription) {
        if (subscription) {
            const subscriptionIndex = this._subscriptions.indexOf(subscription);
            if (subscriptionIndex > -1) {
                this._subscriptions.splice(subscriptionIndex, 1);
            }
        }
    }
    _onQueueTimerTick() {
        if (!this._canExecute()) {
            this._setupQueueTimer();
            this._logger.trace('_onQueueTimerTick(): canExecute() check failed. ignore current execution');
            return;
        }
        this._logger.debug('prepare server poll request');
        const now = Number(new Date());
        const itemsToBeExecuted = this._getPollQueueList()
            .filter(item => item.queryEnabled && (!item.lastExecution || (Number(item.lastExecution) + (item.interval * 1000) <= now)));
        if (!itemsToBeExecuted.length) {
            this._logger.debug('nothing to run. Waiting next tick...');
            this._setupQueueTimer();
            return;
        }
        this._logger.info(`set busy mode to true`);
        this._state.next({ busy: true });
        this._queryPollItems(itemsToBeExecuted)
            .subscribe(() => {
            this._state.next({ busy: false });
            this._setupQueueTimer();
        }, (error) => {
            this._state.next({ busy: false });
        });
    }
    _propagateServerResponse(item, response) {
        try {
            if (this._pollQueue[item.id]) {
                this._logger.debug(`propagating response for ${item.id}`);
                item.lastExecution = new Date();
                item.observer.next(response);
            }
            else {
                this._logger.info(`cannot find registered action for '${item.id} (it might indicate that this action was unsubscribed while a request to the server was executed)`);
            }
        }
        catch (err) {
            this._logger.warn(`error happened while propagating response of '${item.id}'.ignoring error. got the following error: ${err.message}`);
        }
    }
    isBusy() {
        return this._state.getValue().busy;
    }
    register(intervalInSeconds, requestFactory) {
        return Observable.create(observer => {
            const newPollId = this._tokenGenerator.generateUnique(Object.keys(this._pollQueue));
            this._logger.info(`register new poll request ${newPollId} (interval = ${intervalInSeconds} seconds)`);
            const newPollItem = this._pollQueue[newPollId] = {
                id: newPollId,
                interval: intervalInSeconds,
                lastExecution: null,
                queryEnabled: false,
                requestFactory: requestFactory,
                observer: observer
            };
            this._logger.info(`execute the added request '${newPollId}'`);
            let initialRequest = this._queryPollItems([newPollItem])
                .subscribe(() => {
                initialRequest = null;
                newPollItem.queryEnabled = true;
                this._setupQueueTimer();
            }, () => {
                initialRequest = null;
                newPollItem.queryEnabled = true;
                this._setupQueueTimer();
            });
            return () => {
                this._logger.info(`stop polling for ${newPollId}`);
                if (initialRequest) {
                    initialRequest.unsubscribe();
                }
                delete this._pollQueue[newPollId];
            };
        });
    }
}

class TrackedFileStatuses {
}
TrackedFileStatuses.added = 'added'; // one-time status, cannot be assigned twice
TrackedFileStatuses.pendingPrepare = 'pendingPrepare';
TrackedFileStatuses.preparing = 'preparing';
TrackedFileStatuses.prepared = 'prepared'; // one-time status, cannot be assigned twice
TrackedFileStatuses.pendingUpload = 'waitingUpload';
TrackedFileStatuses.uploading = 'uploading';
TrackedFileStatuses.uploadCompleted = 'uploadCompleted'; // one-time status, cannot be assigned twice
TrackedFileStatuses.failure = 'failure';
TrackedFileStatuses.cancelled = 'cancelled';
TrackedFileStatuses.purged = 'purged'; // one-time status, cannot be assigned twice
class TrackedFile {
    constructor(id, data) {
        this.status = TrackedFileStatuses.added;
        this.progress = 0;
        this.uploadCompleteAt = null;
        this.uploadOrder = 0;
        this._statusHistory = {
            'added': true
        };
        this._id = id;
        this.data = data;
    }
    get id() {
        return this._id;
    }
    asData() {
        return {
            id: this.id,
            status: this.status,
            uploadStartAt: this.uploadStartAt,
            progress: this.progress,
            uploadCompleteAt: this.uploadCompleteAt,
            uploadOrder: this.uploadOrder,
            failureType: this.failureType,
            failureReason: this.failureReason,
            data: this.data
        };
    }
    update(changes) {
        if (changes.status && changes.status !== this.status) {
            if (!this.canTransitionTo(changes.status)) {
                throw new Error(`file ${this.id}: cannot update status to '${changes.status}'`);
            }
            this._statusHistory[changes.status] = true;
        }
        Object.assign(this, changes);
    }
    wasInStatus(status) {
        return !!this._statusHistory[status];
    }
    canTransitionTo(toStatus) {
        let result = false;
        const trackedFile = this;
        const fromStatus = trackedFile ? trackedFile.status : null;
        if (trackedFile && fromStatus && toStatus) {
            if (fromStatus === TrackedFileStatuses.purged) {
                // never allow changing status once file was purged
                result = false;
            }
            switch (toStatus) {
                case TrackedFileStatuses.added:
                    // one-time status, cannot be assigned twice
                    result = !this.wasInStatus(TrackedFileStatuses.added);
                    break;
                case TrackedFileStatuses.pendingPrepare:
                    result = !this.wasInStatus(TrackedFileStatuses.prepared);
                    break;
                case TrackedFileStatuses.preparing:
                    result = !this.wasInStatus(TrackedFileStatuses.prepared)
                        && fromStatus === TrackedFileStatuses.pendingPrepare;
                    break;
                case TrackedFileStatuses.prepared:
                    // one-time status, cannot be assigned twice
                    result = !this.wasInStatus(TrackedFileStatuses.prepared)
                        && fromStatus === TrackedFileStatuses.preparing;
                    break;
                case TrackedFileStatuses.pendingUpload:
                    result = this.wasInStatus(TrackedFileStatuses.prepared)
                        && !this.wasInStatus(TrackedFileStatuses.uploadCompleted);
                    break;
                case TrackedFileStatuses.uploading:
                    result = !this.wasInStatus(TrackedFileStatuses.uploadCompleted)
                        && fromStatus === TrackedFileStatuses.pendingUpload;
                    break;
                case TrackedFileStatuses.uploadCompleted:
                    // one-time status, cannot be assigned twice
                    result = !this.wasInStatus(TrackedFileStatuses.uploadCompleted)
                        && fromStatus === TrackedFileStatuses.uploading;
                    break;
                case TrackedFileStatuses.cancelled:
                    result = ([TrackedFileStatuses.cancelled, TrackedFileStatuses.uploadCompleted, TrackedFileStatuses.purged].indexOf(fromStatus) === -1);
                    break;
                case TrackedFileStatuses.failure:
                    // always allow changing to 'failure' status (assuming 'purge' is handled separately before)
                    result = ([TrackedFileStatuses.uploadCompleted, TrackedFileStatuses.purged].indexOf(fromStatus) === -1);
                    break;
                case TrackedFileStatuses.purged:
                    // one-time status, cannot be assigned twice
                    result = !this.wasInStatus(TrackedFileStatuses.purged);
                    break;
                default:
                    throw new Error(`unknown status provided '${toStatus}'`);
            }
        }
        return result;
    }
}

const __ngOnDestroySource__ = Symbol("__ngOnDestroySource__");
const __ngOnDestroy__ = Symbol("__ngOnDestroy__");
function cancelOnDestroy(instance, manualDestroy) {
    return (source) => source.lift(new CancelOnDestroyOperator(instance, manualDestroy));
}
class CancelOnDestroyOperator {
    constructor(instance, manualDestroy) {
        this.instance = instance;
        this.manualDestroy = manualDestroy;
        if (instance.ngOnDestroy) {
            if (!instance[__ngOnDestroySource__]) {
                instance[__ngOnDestroySource__] = new Subject();
                instance[__ngOnDestroy__] = instance.ngOnDestroy;
                instance.ngOnDestroy = function () {
                    this[__ngOnDestroy__].apply(this, arguments);
                    this[__ngOnDestroySource__].next();
                    this[__ngOnDestroySource__].complete();
                };
            }
        }
    }
    call(subscriber, source) {
        return source.subscribe(new CancelOnDestroySubscriber(subscriber, this.instance, this.manualDestroy));
    }
}
class CancelOnDestroySubscriber extends Subscriber {
    constructor(destination, _instance, manualDestroy) {
        super(destination);
        this._instance = _instance;
        this.manualDestroy = manualDestroy;
        const sources = manualDestroy
            ? merge(manualDestroy, _instance[__ngOnDestroySource__])
            : _instance[__ngOnDestroySource__].asObservable();
        this.add(sources.subscribe(() => {
            destination.unsubscribe();
        }));
    }
}

function tag(action) {
    return (source) => source.lift(new TagOperator(action));
}
class TagOperator {
    constructor(_tag) {
        this._tag = _tag;
    }
    call(subscriber, source) {
        return source.subscribe(new TagSubscriber(subscriber, this._tag));
    }
}
class TagSubscriber extends Subscriber {
    constructor(destination, _tag) {
        super(destination);
        this._tag = _tag;
        this._isDecreased = false;
        OperationTagStoreMediator.increase(this._tag);
    }
    _error(err) {
        if (this._tag && !this._isDecreased) {
            this._isDecreased = true;
            OperationTagStoreMediator.decrease(this._tag);
        }
        super._error(err);
    }
    _complete() {
        if (this._tag && !this._isDecreased) {
            this._isDecreased = true;
            OperationTagStoreMediator.decrease(this._tag);
        }
        super._complete();
    }
    unsubscribe() {
        if (!this.closed && this._tag && !this._isDecreased) {
            this._isDecreased = true;
            OperationTagStoreMediator.decrease(this._tag);
        }
        super.unsubscribe();
    }
}

const UploadFileAdapterToken = new InjectionToken('upload-file-adapter');
let UploadManagement = class UploadManagement {
    constructor(_uploadFileAdapter) {
        this._uploadFileAdapter = _uploadFileAdapter;
        this._trackedFiles = {};
        this._onTrackedFileChanged = new Subject();
        this._maxUploadRequests = null;
        this.onTrackedFileChanged$ = this._onTrackedFileChanged.asObservable();
        this._tokenGenerator = new FriendlyHashId();
    }
    setMaxUploadRequests(maxUploads) {
        if (maxUploads === null || maxUploads > 0) {
            this._log('info', `limit max upload requests to ${maxUploads}`);
            this._maxUploadRequests = maxUploads;
        }
        else {
            this._log('info', `remove max upload limitation`);
            this._maxUploadRequests = null;
        }
    }
    // TODO [kmcng] replace this function with log library
    _log(level, message, fileId) {
        const messageContext = fileId ? `file '${fileId}'` : '';
        const origin = 'upload manager';
        const formattedMessage = `log: [${level}] [${origin}] ${messageContext}: ${message}`;
        switch (level) {
            case 'silly':
            case 'debug':
            case 'info':
                console.log(formattedMessage);
                break;
            case 'warn':
                console.warn(formattedMessage);
                break;
            case 'error':
                console.error(formattedMessage);
                break;
        }
    }
    getTrackedFiles() {
        return Object.keys(this._trackedFiles).map(fileId => this._trackedFiles[fileId].asData());
    }
    getTrackedFile(fileId) {
        const relevantFile = this._trackedFiles[fileId];
        return relevantFile ? relevantFile.asData() : null;
    }
    addFile(file) {
        const [newFileId] = this.addFiles([file]);
        return newFileId;
    }
    addFiles(files) {
        const result = [];
        files.forEach((fileData) => {
            const newUploadId = this._tokenGenerator.generateUnique(Object.keys(this._trackedFiles));
            this._log('info', `add new file '${fileData.getFileName()}' to queue with unique file id`, newUploadId);
            this._createTrackedFile(newUploadId, fileData);
            result.push({ id: newUploadId, data: fileData });
        });
        if (result.length) {
            this._syncUploadQueue();
        }
        return result;
    }
    cancelUploadWithError(id, reason) {
        this._log('info', `cancel file upload with custom reason '${reason}'`, id);
        const trackedFile = this._trackedFiles[id];
        if (trackedFile) {
            {
                if (trackedFile.canTransitionTo(TrackedFileStatuses.cancelled)) {
                    this.cancelUpload(id, false);
                    if (trackedFile.canTransitionTo(TrackedFileStatuses.failure)) {
                        this._updateTrackedFile(trackedFile, {
                            status: TrackedFileStatuses.failure,
                            failureReason: reason || 'unknown error',
                            failureType: 'manual_error'
                        });
                    }
                }
            }
        }
        else {
            this._log('warn', 'cannot cancel upload, failed to find file with provided id', id);
        }
    }
    resumeUpload(id) {
        this.resumeUploads([id]);
    }
    resumeUploads(files) {
        let syncUploadQueue = false;
        files.forEach(id => {
            this._log('info', `resume file upload.`, id);
            const trackedFile = this._trackedFiles[id];
            if (trackedFile) {
                if (trackedFile.wasInStatus(TrackedFileStatuses.prepared)) {
                    this._updateTrackedFile(trackedFile, {
                        status: TrackedFileStatuses.pendingUpload
                    });
                }
                else {
                    this._updateTrackedFile(trackedFile, {
                        status: TrackedFileStatuses.pendingPrepare
                    });
                }
            }
            else {
                this._log('warn', 'cannot resume upload, failed to find file with provided id', id);
            }
        });
        this._syncUploadQueue();
    }
    cancelUpload(id, purge = true) {
        this._log('info', `cancel file upload.`, id);
        const trackedFile = this._trackedFiles[id];
        if (trackedFile) {
            if (trackedFile.status !== TrackedFileStatuses.cancelled
                && trackedFile.canTransitionTo(TrackedFileStatuses.cancelled)) {
                if (trackedFile.uploadSubscription) {
                    trackedFile.uploadSubscription.unsubscribe();
                    trackedFile.uploadSubscription = null;
                }
                this._updateTrackedFile(trackedFile, {
                    status: TrackedFileStatuses.cancelled
                });
                if (purge) {
                    this.purgeUpload(id);
                }
                this._syncUploadQueue();
            }
        }
        else {
            this._log('warn', 'cannot cancel upload, failed to find file with provided id', id);
        }
    }
    purgeUpload(id) {
        this._log('info', `purge file from queue.`, id);
        const trackedFile = this._trackedFiles[id];
        if (trackedFile) {
            if (trackedFile.canTransitionTo(TrackedFileStatuses.purged)) {
                this.cancelUpload(id, false);
                this._updateTrackedFile(trackedFile, { status: TrackedFileStatuses.purged });
                this._removeTrackedFile(trackedFile);
            }
        }
        else {
            this._log('warn', 'cannot purge upload, failed to find file with provided id', id);
        }
    }
    _removeTrackedFile(trackedFile) {
        this._log('info', `remove tracked file from queue`, trackedFile.id);
        // Developer notice - this is a cleanup function just in case.
        if (trackedFile.uploadSubscription) {
            trackedFile.uploadSubscription.unsubscribe();
            trackedFile.uploadSubscription = null;
        }
        delete this._trackedFiles[trackedFile.id];
    }
    _syncUploadQueue() {
        if (this.syncUploadQueueTimeoutId) {
            clearTimeout(this.syncUploadQueueTimeoutId);
            this.syncUploadQueueTimeoutId = null;
        }
        // DEVELOPER NOTICE: This logic is delayed to the next event loop on purpose to prevent
        // collision between two sync requests
        this.syncUploadQueueTimeoutId = setTimeout(() => {
            this._log('info', `syncing upload queue`);
            this.syncUploadQueueTimeoutId = null;
            this._executePreparePhase();
            this._executeUploadPhase();
        }, 200);
    }
    _executePreparePhase() {
        const files = Object.keys(this._trackedFiles).map(fileId => this._trackedFiles[fileId]).filter(trackedFile => {
            return trackedFile.status === TrackedFileStatuses.pendingPrepare
                && trackedFile.canTransitionTo(TrackedFileStatuses.preparing);
        });
        if (files.length) {
            this._log('info', `handling ${files.length} files, waiting to be prepared`);
            const groupedFiles = files.reduce((acc, curr) => {
                const uploadAdapter = this._getUploadAdapter(curr.data) || null;
                const matchedItem = acc.find(item => item.adapter ? item.adapter.constructor === uploadAdapter.constructor : item.adapter === null);
                if (matchedItem) {
                    matchedItem.files.push(curr);
                }
                else {
                    acc.push({ adapter: uploadAdapter, files: [curr] });
                }
                return acc;
            }, []);
            groupedFiles.forEach(item => {
                if (item.adapter) {
                    this._log('debug', `executing prepare phase for ${item.files.length} files with adapter '${item.adapter.label}'`);
                    item.files.forEach(file => {
                        this._updateTrackedFile(file, { status: TrackedFileStatuses.preparing });
                    });
                    item.adapter.prepare(item.files)
                        .pipe(cancelOnDestroy(this))
                        .subscribe(preparedFiles => {
                        this._log('debug', `executing prepare phase succeeded for ${item.files.length} files with adapter '${item.adapter.label}'.`);
                        this._handlePrepareAdapterResponse(preparedFiles);
                        this._syncUploadQueue();
                    }, reason => {
                        this._log('error', `executing prepare phase failed for ${item.files.length} files with adapter '${item.adapter.label}'. error: ${reason.message}`);
                        this._handlePrepareAdapterResponse(item.files.map(file => ({ id: file.id, status: false })));
                        this._syncUploadQueue();
                    });
                }
                else {
                    item.files.forEach(file => {
                        this._updateTrackedFile(file, {
                            status: TrackedFileStatuses.failure,
                            failureReason: 'upload destination is not supported',
                            failureType: 'unknown_destination'
                        });
                    });
                }
            });
        }
    }
    _handlePrepareAdapterResponse(responseFiles) {
        responseFiles.forEach(responseFile => {
            const trackedFile = this._trackedFiles[responseFile.id];
            if (!trackedFile) {
                this._log('warn', `cannot handle prepare response for file '${responseFile.id}' since there is no tracking information for that file (did the user purge the file during the prepare execution?)`);
            }
            else if (trackedFile.status !== TrackedFileStatuses.preparing) {
                this._log('warn', `cannot handle file result from prepare action (did the user cancel the file upload during the prepare execution?)`, trackedFile.id);
            }
            else if (responseFile.status) {
                const changedStatusToPrepared = this._updateTrackedFile(trackedFile, {
                    status: TrackedFileStatuses.prepared
                });
                if (changedStatusToPrepared) {
                    this._updateTrackedFile(trackedFile, {
                        status: TrackedFileStatuses.pendingUpload
                    });
                }
            }
            else {
                this._updateTrackedFile(trackedFile, {
                    status: TrackedFileStatuses.failure,
                    failureReason: 'failed to prepare upload',
                    failureType: 'preparation_failed'
                });
            }
        });
    }
    _executeUploadPhase() {
        const waitingForUploadsFiles = [];
        const activeUploadFiles = [];
        Object.keys(this._trackedFiles).forEach(fileId => {
            const trackedFile = this._trackedFiles[fileId];
            if (trackedFile.status === TrackedFileStatuses.uploading) {
                activeUploadFiles.push(trackedFile);
            }
            else if (trackedFile.status === TrackedFileStatuses.pendingUpload
                && trackedFile.canTransitionTo(TrackedFileStatuses.uploading)) {
                waitingForUploadsFiles.push(trackedFile);
            }
        });
        const activeUploadsCount = activeUploadFiles.length;
        const waitingFilesCount = waitingForUploadsFiles.length;
        if (waitingFilesCount > 0) {
            let nextUploadFiles = [];
            this._log('silly', `active uploads: ${activeUploadsCount} | pending files: ${waitingFilesCount}`);
            const availableUploadSlots = (this._maxUploadRequests && this._maxUploadRequests > 0) ? this._maxUploadRequests - activeUploadsCount : waitingFilesCount;
            if (availableUploadSlots > 0) {
                nextUploadFiles = [
                    ...waitingForUploadsFiles.sort(pendingFile => pendingFile.uploadOrder || 1000)
                ].slice(0, availableUploadSlots);
            }
            this._log('debug', `available upload slots to be used ${availableUploadSlots}`);
            nextUploadFiles.forEach(pendingFile => {
                this._initiateUpload(pendingFile);
            });
        }
    }
    _createTrackedFile(id, fileData) {
        const newTrackedFile = this._trackedFiles[id] = new TrackedFile(id, fileData);
        this._onTrackedFileChanged.next(newTrackedFile.asData());
        this._updateTrackedFile(newTrackedFile, { status: TrackedFileStatuses.pendingPrepare });
    }
    _updateTrackedFile(trackedFile, changes) {
        let result = true;
        if (changes.status && changes.status !== trackedFile.status) {
            if (trackedFile.canTransitionTo(changes.status)) {
                this._log('info', `notify file status changes from '${trackedFile.status}' to '${changes.status}'`, trackedFile.id);
                trackedFile.update(changes);
            }
            else {
                this._log('error', `cannot update file data from '${trackedFile.status}' to '${changes.status}. target status is not allowed. update to status 'failure' instead.`, trackedFile.id);
                trackedFile.update({
                    status: TrackedFileStatuses.failure,
                    failureReason: 'cannot change status',
                    failureType: 'change_not_allowed'
                });
                result = false;
            }
        }
        else {
            //this._log('info', `notify file data changes`,trackedFile.id);
            trackedFile.update(changes);
        }
        this._onTrackedFileChanged.next(trackedFile.asData());
        return result;
    }
    supportChunkUpload(uploadFileData) {
        const uploadAdapter = this._getUploadAdapter(uploadFileData);
        return uploadAdapter ? uploadAdapter.supportChunkUpload() : false;
    }
    _initiateUpload(trackedFile) {
        const { data, id } = trackedFile;
        const uploadAdapter = this._getUploadAdapter(data);
        this._log('info', `initiate new upload for file '${id}'`);
        if (!uploadAdapter) {
            this._log('warn', `cannot find destination adapter for requested file, failing upload request`);
            this._updateTrackedFile(trackedFile, {
                status: TrackedFileStatuses.failure,
                failureReason: 'upload destination is not supported',
                failureType: 'unknown_destination'
            });
            this._syncUploadQueue();
        }
        else if (trackedFile.canTransitionTo(TrackedFileStatuses.uploading)) {
            if (trackedFile.uploadSubscription) {
                this._log('warn', `an active upload was found while the status indicated no upload currently in progress. cancel previous upload`);
                trackedFile.uploadSubscription.unsubscribe();
                trackedFile.uploadSubscription = null;
            }
            this._updateTrackedFile(trackedFile, {
                status: TrackedFileStatuses.uploading,
                progress: 0,
                uploadStartAt: new Date(),
            });
            const canHandleResponse = (id, actionDescription) => {
                let result = false;
                const trackedFileStillExists = !!this._trackedFiles[id];
                if (!trackedFileStillExists) {
                    this._log('warn', `cannot handle file upload ${actionDescription}. There is no tracking file with the provided id (was the file purged?)`, id);
                }
                else if (trackedFile.status !== TrackedFileStatuses.uploading) {
                    this._log('warn', `cannot handle file upload ${actionDescription}. The file status it not 'uploading' (was the file upload cancelled?)`, id);
                }
                else {
                    result = true;
                }
                return result;
            };
            trackedFile.uploadSubscription = uploadAdapter.upload(id, data)
                .subscribe((uploadChanges) => {
                if (canHandleResponse(id, 'progress')) {
                    this._updateTrackedFile(trackedFile, {
                        progress: uploadChanges.progress
                    });
                }
            }, (error) => {
                trackedFile.uploadSubscription = null;
                if (canHandleResponse(id, 'failure')) {
                    const failureReason = error && error.message ? error.message : '';
                    this._updateTrackedFile(trackedFile, {
                        status: TrackedFileStatuses.failure,
                        failureReason,
                        failureType: 'general_error'
                    });
                }
                this._syncUploadQueue();
            }, () => {
                trackedFile.uploadSubscription = null;
                if (canHandleResponse(id, 'completion')) {
                    this._updateTrackedFile(trackedFile, {
                        status: TrackedFileStatuses.uploadCompleted,
                        progress: 1,
                        uploadCompleteAt: new Date()
                    });
                    this._removeTrackedFile(trackedFile);
                    this._syncUploadQueue();
                }
            });
        }
    }
    _getUploadAdapter(fileData) {
        if (this._uploadFileAdapter) {
            return this._uploadFileAdapter.find(uploadFileAdapter => {
                return uploadFileAdapter.canHandle(fileData);
            });
        }
        else {
            return null;
        }
    }
    ngOnDestroy() {
        Object.keys(this._trackedFiles).forEach(id => {
            this.purgeUpload(id);
        });
    }
};
UploadManagement.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [UploadFileAdapterToken,] }, { type: Optional }] }
];
UploadManagement = __decorate([
    Injectable(),
    __param(0, Inject(UploadFileAdapterToken)), __param(0, Optional()),
    __metadata("design:paramtypes", [Array])
], UploadManagement);

let UploadManagementModule = class UploadManagementModule {
};
UploadManagementModule = __decorate([
    NgModule({
        imports: [],
        declarations: [],
        exports: [],
        providers: [
            UploadManagement
        ]
    })
], UploadManagementModule);

class UploadFileAdapter {
}

//download.js v4.2, by dandavis; 2008-2016. [CCBY2] see http://danml.com/download.html for tests/usage
const Download = function (data, strFileName, strMimeType) {
    var self = window, // this script is only for browsers anyway...
    defaultMime = "application/octet-stream", // this default mime also triggers iframe downloads
    mimeType = strMimeType || defaultMime, payload = data, url = !strFileName && !strMimeType && payload, anchor = document.createElement("a"), toString = function (a) { return String(a); }, myBlob = (self['Blob'] || self['MozBlob'] || self['WebKitBlob'] || toString), fileName = strFileName || "download", blob, reader;
    myBlob = myBlob.call ? myBlob.bind(self) : Blob;
    if (String(this) === "true") { //reverse arguments, allowing download.bind(true, "text/xml", "export.xml") to act as a callback
        payload = [payload, mimeType];
        mimeType = payload[0];
        payload = payload[1];
    }
    //go ahead and download dataURLs right away
    if (/^data\:[\w+\-]+\/[\w+\-]+[,;]/.test(payload)) {
        if (payload.length > (1024 * 1024 * 1.999) && myBlob !== toString) {
            payload = dataUrlToBlob(payload);
            mimeType = payload.type || defaultMime;
        }
        else {
            return navigator.msSaveBlob ? // IE10 can't do a[download], only Blobs:
                navigator.msSaveBlob(dataUrlToBlob(payload), fileName) :
                saver(payload, false); // everyone else can save dataURLs un-processed
        }
    } //end if dataURL passed?
    blob = payload instanceof myBlob ?
        payload :
        new myBlob([payload], { type: mimeType });
    function dataUrlToBlob(strUrl) {
        var parts = strUrl.split(/[:;,]/), type = parts[1], decoder = parts[2] == "base64" ? atob : decodeURIComponent, binData = decoder(parts.pop()), mx = binData.length, i = 0, uiArr = new Uint8Array(mx);
        for (i; i < mx; ++i)
            uiArr[i] = binData.charCodeAt(i);
        return new myBlob([uiArr], { type: type });
    }
    function saver(url, winMode) {
        if ('download' in anchor) { //html5 A[download]
            anchor.href = url;
            anchor.setAttribute("download", fileName);
            anchor.className = "download-js-link";
            anchor.innerHTML = "downloading...";
            anchor.style.display = "none";
            document.body.appendChild(anchor);
            setTimeout(function () {
                anchor.click();
                document.body.removeChild(anchor);
                if (winMode === true) {
                    setTimeout(function () { self.URL.revokeObjectURL(anchor.href); }, 250);
                }
            }, 66);
            return true;
        }
        // handle non-a[download] safari as best we can:
        if (/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent)) {
            url = url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
            if (!window.open(url)) { // popup blocked, offer direct download:
                if (confirm("Displaying New Document\n\nUse Save As... to download, then click back to return to this page.")) {
                    location.href = url;
                }
            }
            return true;
        }
        //do iframe dataURL download (old ch+FF):
        var f = document.createElement("iframe");
        document.body.appendChild(f);
        if (!winMode) { // force a mime that will download:
            url = "data:" + url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
        }
        f.src = url;
        setTimeout(function () { document.body.removeChild(f); }, 333);
    } //end saver
    if (navigator.msSaveBlob) { // IE10+ : (has Blob, but not a[download] or URL)
        return navigator.msSaveBlob(blob, fileName);
    }
    if (self.URL) { // simple fast and modern way using Blob and URL:
        saver(self.URL.createObjectURL(blob), true);
    }
    else {
        // handle non-Blob()+non-URL browsers:
        if (typeof blob === "string" || blob.constructor === toString) {
            try {
                return saver("data:" + mimeType + ";base64," + self.btoa(blob), false);
            }
            catch (y) {
                return saver("data:" + mimeType + "," + encodeURIComponent(blob), false);
            }
        }
        // Blob but not URL support:
        reader = new FileReader();
        reader.onload = function (e) {
            saver(this.result, false);
        };
        reader.readAsDataURL(blob);
    }
    return true;
};

const _xmlCharMap = {
    '<': '&lt;',
    '>': '&gt;',
    '&': '&amp;'
};
class KalturaUtils {
    static escapeXml(value) {
        let parsedValue = value;
        switch (typeof value) {
            case 'string':
            case 'number':
            case 'boolean':
                parsedValue = value;
                break;
            default:
                parsedValue = value || '';
                break;
        }
        return String(parsedValue).replace(/[&<>]/g, char => _xmlCharMap[char]);
    }
    static getStartDateValue(value) {
        if (value) {
            const newValue = new Date(value.getTime());
            newValue.setHours(0);
            newValue.setMinutes(0);
            newValue.setSeconds(0);
            return newValue;
        }
        else {
            return null;
        }
    }
    static getEndDateValue(value) {
        if (value) {
            const newValue = new Date(value.getTime());
            newValue.setHours(23);
            newValue.setMinutes(59);
            newValue.setSeconds(59);
            return newValue;
        }
        else {
            return null;
        }
    }
    static removeEmptyProperties(value) {
        Object.keys(value).forEach(function (key) {
            if (value[key] && typeof value[key] === 'object') {
                KalturaUtils.removeEmptyProperties(value[key]);
            }
            else if (value[key] === null) {
                delete value[key];
            }
        });
        return value;
    }
    static moveUpItems(list, selectedItems) {
        if (list && list.length && selectedItems && selectedItems.length) {
            const relevantItems = selectedItems.map(item => ({ selectedItem: item, index: list.indexOf(item) }))
                .filter(item => item.index !== -1)
                .sort((a, b) => a.index - b.index);
            if (relevantItems.length) {
                const minIndexInSelected = relevantItems[0].index;
                const nextIndex = Math.max(0, minIndexInSelected - 1);
                relevantItems.forEach((item, i) => {
                    list.splice(item.index - i, 1);
                });
                list.splice(nextIndex, 0, ...relevantItems.map(item => item.selectedItem));
                return true;
            }
        }
        return false;
    }
    static moveDownItems(list, selectedItems) {
        if (selectedItems && selectedItems.length && list && list.length) {
            const relevantItems = selectedItems.map(item => ({ selectedItem: item, index: list.indexOf(item) }))
                .filter(item => item.index !== -1)
                .sort((a, b) => a.index - b.index);
            if (relevantItems.length) {
                const maxIndexInSelected = relevantItems[relevantItems.length - 1].index;
                const nextIndex = Math.min(list.length - 1, maxIndexInSelected + 1);
                relevantItems.forEach((item, i) => {
                    list.splice(item.index - i, 1);
                });
                const correctedIndex = nextIndex - relevantItems.length;
                list.splice(correctedIndex + 1, 0, ...relevantItems.map(item => item.selectedItem));
                return true;
            }
        }
        return false;
    }
    static formatTime(value, addTimeChars = false) {
        let hours = Math.floor(Math.round(value) / 3600) % 24;
        let minutes = Math.floor((Math.round(value) / 60) % 60);
        let seconds = Math.round(value) % 60;
        let hoursStr = hours === 0 ? '' : addTimeChars ? hours.toString() + "h:" : hours.toString() + ":";
        let minutesStr = minutes === 0 && hours === 0 ? '00' : minutes < 10 ? '0' + minutes.toString() : minutes.toString();
        let secondsStr = seconds < 10 ? '0' + seconds.toString() : seconds.toString();
        if (addTimeChars) {
            minutesStr = minutesStr + "m";
            secondsStr = secondsStr + "s";
        }
        return hoursStr + minutesStr + ":" + secondsStr;
    }
    static fromServerDate(value) {
        return (value ? new Date(value * 1000) : null);
    }
    static toServerDate(value) {
        return value ? Math.round(value.getTime() / 1000) : null;
    }
    static download(data, strFileName, strMimeType) {
        return Download(data, strFileName, strMimeType);
    }
}

/* Copyright 2013 William Summers, Metatribal Research
 * adapted from https://developer.mozilla.org/en-US/docs/JXON
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @author William Summers
 *
 */
const XmlToJSON = (function () {
    var options = {
        mergeCDATA: true,
        grokAttr: true,
        grokText: true,
        normalize: true,
        xmlns: true,
        namespaceKey: '_ns',
        textKey: '_text',
        valueKey: '_value',
        attrKey: '_attr',
        cdataKey: '_cdata',
        attrsAsObject: true,
        stripAttrPrefix: true,
        stripElemPrefix: true,
        childrenAsArray: true // force children into arrays
    };
    var prefixMatch = new RegExp(/(?!xmlns)^.*:/);
    var trimMatch = new RegExp(/^\s+|\s+$/g);
    var grokType = function (sValue) {
        if (/^\s*$/.test(sValue)) {
            return null;
        }
        if (/^(?:true|false)$/i.test(sValue)) {
            return sValue.toLowerCase() === "true";
        }
        if (isFinite(sValue)) {
            return parseFloat(sValue);
        }
        return sValue;
    };
    var parseString = function (xmlString, opt) {
        return this.parseXML(stringToXML(xmlString), opt);
    };
    var parseXML = function (oXMLParent, opt) {
        // initialize options
        for (let key in opt) {
            options[key] = opt[key];
        }
        var vResult = {}, nLength = 0, sCollectedTxt = "";
        // parse namespace information
        if (options.xmlns && oXMLParent.namespaceURI) {
            vResult[options.namespaceKey] = oXMLParent.namespaceURI;
        }
        // parse attributes
        // using attributes property instead of hasAttributes method to support older browsers
        if (oXMLParent.attributes && oXMLParent.attributes.length > 0) {
            var vAttribs = {};
            for (nLength; nLength < oXMLParent.attributes.length; nLength++) {
                let oAttrib = oXMLParent.attributes.item(nLength);
                vContent = {};
                let attribName = '';
                if (options.stripAttrPrefix) {
                    attribName = oAttrib.name.replace(prefixMatch, '');
                }
                else {
                    attribName = oAttrib.name;
                }
                if (options.grokAttr) {
                    vContent[options.valueKey] = grokType(oAttrib.value.replace(trimMatch, ''));
                }
                else {
                    vContent[options.valueKey] = oAttrib.value.replace(trimMatch, '');
                }
                if (options.xmlns && oAttrib.namespaceURI) {
                    vContent[options.namespaceKey] = oAttrib.namespaceURI;
                }
                if (options.attrsAsObject) { // attributes with same local name must enable prefixes
                    vAttribs[attribName] = vContent;
                }
                else {
                    vResult[options.attrKey + attribName] = vContent;
                }
            }
            if (options.attrsAsObject) {
                vResult[options.attrKey] = vAttribs;
            }
            else { }
        }
        // iterate over the children
        if (oXMLParent.hasChildNodes()) {
            for (var oNode, sProp, vContent, nItem = 0; nItem < oXMLParent.childNodes.length; nItem++) {
                oNode = oXMLParent.childNodes.item(nItem);
                if (oNode.nodeType === 4) {
                    if (options.mergeCDATA) {
                        sCollectedTxt += oNode.nodeValue;
                    }
                    else {
                        if (vResult.hasOwnProperty(options.cdataKey)) {
                            if (vResult[options.cdataKey].constructor !== Array) {
                                vResult[options.cdataKey] = [vResult[options.cdataKey]];
                            }
                            vResult[options.cdataKey].push(oNode.nodeValue);
                        }
                        else {
                            if (options.childrenAsArray) {
                                vResult[options.cdataKey] = [];
                                vResult[options.cdataKey].push(oNode.nodeValue);
                            }
                            else {
                                vResult[options.cdataKey] = oNode.nodeValue;
                            }
                        }
                    }
                } /* nodeType is "CDATASection" (4) */
                else if (oNode.nodeType === 3) {
                    sCollectedTxt += oNode.nodeValue;
                } /* nodeType is "Text" (3) */
                else if (oNode.nodeType === 1) { /* nodeType is "Element" (1) */
                    if (nLength === 0) {
                        vResult = {};
                    }
                    // using nodeName to support browser (IE) implementation with no 'localName' property
                    if (options.stripElemPrefix) {
                        sProp = oNode.nodeName.replace(prefixMatch, '');
                    }
                    else {
                        sProp = oNode.nodeName;
                    }
                    vContent = parseXML(oNode);
                    if (vResult.hasOwnProperty(sProp)) {
                        if (vResult[sProp].constructor !== Array) {
                            vResult[sProp] = [vResult[sProp]];
                        }
                        vResult[sProp].push(vContent);
                    }
                    else {
                        if (options.childrenAsArray) {
                            vResult[sProp] = [];
                            vResult[sProp].push(vContent);
                        }
                        else {
                            vResult[sProp] = vContent;
                        }
                        nLength++;
                    }
                }
            }
        }
        else if (!sCollectedTxt) { // no children and no text, return null
            if (options.childrenAsArray) {
                vResult[options.textKey] = [];
                vResult[options.textKey].push(null);
            }
            else {
                vResult[options.textKey] = null;
            }
        }
        if (sCollectedTxt) {
            if (options.grokText) {
                let value = grokType(sCollectedTxt.replace(trimMatch, ''));
                if (value) {
                    vResult[options.textKey] = value;
                }
            }
            else if (options.normalize) {
                vResult[options.textKey] = sCollectedTxt.replace(trimMatch, '').replace(/\s+/g, " ");
            }
            else {
                vResult[options.textKey] = sCollectedTxt.replace(trimMatch, '');
            }
        }
        return vResult;
    };
    // Convert xmlDocument to a string
    // Returns null on failure
    var xmlToString = function (xmlDoc) {
        try {
            var xmlString = xmlDoc.xml ? xmlDoc.xml : (new XMLSerializer()).serializeToString(xmlDoc);
            return xmlString;
        }
        catch (err) {
            return null;
        }
    };
    // Convert a string to XML Node Structure
    // Returns null on failure
    var stringToXML = function (xmlString) {
        try {
            var xmlDoc = null;
            if (typeof DOMParser === 'function') {
                var parser = new DOMParser();
                xmlDoc = parser.parseFromString(xmlString, "text/xml");
                return xmlDoc;
            }
            else {
                return null;
                // TODO [kmcng] consider if to allow active x object
                // xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                // xmlDoc.async = false;
                // xmlDoc.loadXML(xmlString);
                //
                // return xmlDoc;
            }
        }
        catch (e) {
            return null;
        }
    };
    // this is the "revealed"/public part of the module
    return {
        parseXML: parseXML,
        parseString: parseString,
        xmlToString: xmlToString,
        stringToXML: stringToXML
    };
}());

function convertAttributes(attributes) {
    let parsedAttributes = '';
    if (attributes) {
        Object.keys(attributes).forEach(attributeName => {
            const value = KalturaUtils.escapeXml(attributes[attributeName]);
            parsedAttributes += ` ${attributeName}="${value}"`;
        });
    }
    return parsedAttributes;
}
function convertObjectToXml(prefix, propertyName, propertyValue) {
    let result = ``;
    const noPrefixPropertyName = (propertyName || '').indexOf('noprefix:') !== -1;
    if (noPrefixPropertyName) {
        propertyName = propertyName.replace('noprefix:', '');
        prefix = '';
    }
    if (Array.isArray(propertyValue)) {
        propertyValue.forEach(innerItem => {
            result += convertObjectToXml(prefix, propertyName, innerItem);
        });
    }
    else if (propertyValue && typeof propertyValue === 'object') {
        const parsedAttributes = convertAttributes(propertyValue['attr']);
        let parsedValue = '';
        if (propertyValue['text']) {
            parsedValue = KalturaUtils.escapeXml(propertyValue['text']);
        }
        else {
            Object.keys(propertyValue).forEach(innerProperty => {
                if (innerProperty !== 'attr') {
                    parsedValue += convertObjectToXml(prefix, innerProperty, propertyValue[innerProperty]);
                }
            });
        }
        result += `<${prefix}${propertyName}`;
        if (parsedAttributes) {
            result += `${parsedAttributes}>`;
        }
        else {
            result += '>';
        }
        result += `${parsedValue}</${prefix}${propertyName}>`;
    }
    return result;
}
class XmlParser {
    static toJson(xml) {
        return XmlToJSON.parseString(xml, {
            textKey: 'text',
            valueKey: 'value',
            attrKey: 'attr',
            cdataKey: 'cdata',
            childrenAsArray: false,
            grokText: false,
            grokAttr: false,
            normalize: false,
        });
    }
    static toXml(data, root, prefix = '') {
        const parsedPrefix = prefix ? `${prefix}:` : '';
        let parsedObject = '';
        let parsedAttributes = '';
        if (data) {
            parsedAttributes = convertAttributes(data['attr']);
            Object.keys(data).forEach(property => {
                if (property !== 'attr') {
                    parsedObject += convertObjectToXml(parsedPrefix, property, data[property]);
                }
            });
        }
        return `<${parsedPrefix}${root}${parsedAttributes}>${parsedObject}</${parsedPrefix}${root}>`;
    }
    static toSimpleXml(data, config = {}) {
        let result = '';
        const _parseValueToXml = (value) => {
            let result;
            if (typeof value === 'object') {
                result = XmlParser.toSimpleXml(value, config);
            }
            else {
                result = KalturaUtils.escapeXml(value);
            }
            return result;
        };
        if (data) {
            Object.keys(data).forEach(function (key) {
                const propertyValue = data[key];
                const isEmptyValue = (propertyValue === null || typeof propertyValue === 'undefined' || propertyValue === '');
                if (!config.removeEmpty || (config.removeEmpty && !isEmptyValue)) {
                    if (propertyValue instanceof Array) {
                        propertyValue.map(arrayItem => {
                            const valueAsXml = _parseValueToXml(arrayItem);
                            const isEmptyValue = (valueAsXml === null || typeof valueAsXml === 'undefined' || valueAsXml === '');
                            if (!config.removeEmpty || (config.removeEmpty && !isEmptyValue)) {
                                result += `<${key}>${valueAsXml}</${key}>`;
                            }
                        });
                    }
                    else if (typeof propertyValue === 'object') {
                        const valueAsXml = _parseValueToXml(propertyValue);
                        const isEmptyValue = (valueAsXml === null || typeof valueAsXml === 'undefined' || valueAsXml === '');
                        if (!config.removeEmpty || (config.removeEmpty && !isEmptyValue)) {
                            result += `<${key}>${valueAsXml}</${key}>`;
                        }
                    }
                    else {
                        const value = KalturaUtils.escapeXml(propertyValue);
                        result += `<${key}>${value}</${key}>`;
                    }
                }
            });
        }
        return result;
    }
}

const APP_STORAGE_TOKEN = new InjectionToken('APP_STORAGE_TOKEN');
class AppStorage {
    constructor() {
        this.storage = {};
    }
    setInLocalStorage(key, value) {
        this.storage[key] = value;
    }
    getFromLocalStorage(key) {
        return this.storage[key];
    }
    removeFromLocalStorage(key) {
        delete this.storage[key];
    }
    setInSessionStorage(key, value) {
        this.storage[key] = value;
    }
    getFromSessionStorage(key) {
        return this.storage[key];
    }
    removeFromSessionStorage(key) {
        delete this.storage[key];
    }
}

var KalturaCommonModule_1;
let KalturaCommonModule = KalturaCommonModule_1 = class KalturaCommonModule {
    // constructor(@Optional() @SkipSelf() module : KalturaCoreModule, private appBootstrap : AppBootstrap)
    // {
    //     if (module) {
    //         throw new Error("KMCngCoreModule module imported twice.");
    //     }
    // }
    static forRoot() {
        return {
            ngModule: KalturaCommonModule_1,
            providers: [
                { provide: APP_STORAGE_TOKEN, useClass: AppStorage },
                KalturaUtils,
                { provide: KalturaLoggerInjectionToken, useClass: EmptyLogger }
            ]
        };
    }
};
KalturaCommonModule = KalturaCommonModule_1 = __decorate([
    NgModule({
        imports: [
            CommonModule,
        ],
        declarations: [],
        exports: [],
        providers: []
    })
], KalturaCommonModule);

/*
 * Public API Surface of kaltura-common
 */

/**
 * Generated bundle index. Do not edit.
 */

export { APP_STORAGE_TOKEN, AppStorage, Download, EmptyLogger, FriendlyHashId, KalturaCommonModule, KalturaLoggerInjectionToken, KalturaUtils, OperationTagManagerService, OperationTagModule, ServerPolls, TrackedFile, TrackedFileStatuses, UploadFileAdapter, UploadFileAdapterToken, UploadManagement, UploadManagementModule, XmlParser, cancelOnDestroy, tag, XmlToJSON as ɵa };
//# sourceMappingURL=kaltura-ng-kaltura-common.js.map

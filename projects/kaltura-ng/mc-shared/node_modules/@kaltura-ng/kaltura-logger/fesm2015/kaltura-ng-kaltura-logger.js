import { __decorate, __param, __metadata } from 'tslib';
import { Injectable, InjectionToken, Inject, Optional, Self, SkipSelf, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { JL } from 'jsnlog';

let KalturaLoggerRecordService = class KalturaLoggerRecordService {
    constructor() {
        this._recordLogs = false;
        this._logsBuffer = [];
    }
    get isRecordingLogs() {
        return this._recordLogs;
    }
    startRecord() {
        this._recordLogs = true;
    }
    getRecordedLogs() {
        const result = [...this._logsBuffer];
        this._recordLogs = false;
        this._logsBuffer = [];
        return result;
    }
    addLogItemToBuffer(logItem) {
        if (this.isRecordingLogs) {
            this._logsBuffer.push(logItem);
        }
    }
};
KalturaLoggerRecordService = __decorate([
    Injectable()
], KalturaLoggerRecordService);

var KalturaLogger_1;
const KalturaLoggerName = new InjectionToken('kaltura-logger-name');
let randomLoggerNameNumber = 1;
let KalturaLogger = KalturaLogger_1 = class KalturaLogger {
    constructor(name, parentLogger, _loggerRecordInterceptor) {
        this._loggerRecordInterceptor = _loggerRecordInterceptor;
        KalturaLogger_1.resetDefaultJSNLog();
        if (!name) {
            name = 'logger' + randomLoggerNameNumber;
            randomLoggerNameNumber++;
        }
        name = name.replace(/[.]/g, '_');
        this._name = parentLogger ? `${parentLogger.name}.${name}` : name;
        this._logger = JL(this._name);
        this._logger.trace('logger created!');
    }
    static resetDefaultJSNLog() {
        if (!KalturaLogger_1.resetDefaultExecuted) {
            KalturaLogger_1.resetDefaultExecuted = true;
            const consoleAppender = JL.createConsoleAppender('consoleAppender');
            JL().setOptions({
                appenders: [consoleAppender]
            });
        }
    }
    static createLogger(loggerName) {
        return [
            KalturaLogger_1,
            {
                provide: KalturaLoggerName, useValue: loggerName
            }
        ];
    }
    get name() {
        return this._name;
    }
    _addLogToBuffer(logItem) {
        if (this._loggerRecordInterceptor) {
            this._loggerRecordInterceptor.addLogItemToBuffer(logItem);
        }
    }
    startRecordingLogs() {
        if (this._loggerRecordInterceptor) {
            this._loggerRecordInterceptor.startRecord();
        }
    }
    getRecordedLogs() {
        if (this._loggerRecordInterceptor) {
            return this._loggerRecordInterceptor.getRecordedLogs();
        }
    }
    isValidLogLevel(level) {
        const validLogLevels = ['All', 'Trace', 'Debug', 'Info', 'Warn', 'Error', 'Fatal', 'Off'];
        return validLogLevels.indexOf(level) !== -1;
    }
    setOptions(options) {
        let level = undefined;
        if (this.isValidLogLevel(options.level) && JL) {
            const getLevelValue = JL[`get${options.level}Level`];
            level = typeof getLevelValue === 'function' ? getLevelValue() : undefined;
        }
        JL().setOptions({ level: level });
    }
    subLogger(name) {
        return new KalturaLogger_1(name, this, this._loggerRecordInterceptor);
    }
    ngOnDestroy() {
        this._logger.debug('logger destroyed');
        delete this._logger;
    }
    _createLogObject(level, message, context) {
        this._addLogToBuffer({ level, message, context });
        return context ? Object.assign({ message, level }, context) : message;
    }
    trace(message, context) {
        if (context && typeof context === 'function') {
            this._logger.trace(() => this._createLogObject('trace', message, context()));
        }
        else {
            this._logger.trace(this._createLogObject('trace', message, context));
        }
    }
    debug(message, context) {
        if (context && typeof context === 'function') {
            this._logger.debug(() => this._createLogObject('debug', message, context()));
        }
        else {
            this._logger.debug(this._createLogObject('debug', message, context));
        }
    }
    info(message, context) {
        if (context && typeof context === 'function') {
            this._logger.info(() => this._createLogObject('info', message, context()));
        }
        else {
            this._logger.info(this._createLogObject('info', message, context));
        }
    }
    warn(message, context) {
        if (context && typeof context === 'function') {
            this._logger.warn(() => this._createLogObject('warn', message, context()));
        }
        else {
            this._logger.warn(this._createLogObject('warn', message, context));
        }
    }
    error(message, context) {
        this._logger.error(this._createLogObject('error', message, context));
    }
    fatal(message, context) {
        if (context && context instanceof Error) {
            this._logger.fatalException(message, context);
        }
        else {
            this._logger.fatal(this._createLogObject('fatal', message, context));
        }
    }
};
KalturaLogger.resetDefaultExecuted = false;
KalturaLogger.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [KalturaLoggerName,] }, { type: Optional }, { type: Self }] },
    { type: KalturaLogger, decorators: [{ type: SkipSelf }, { type: Optional }] },
    { type: KalturaLoggerRecordService, decorators: [{ type: Optional }] }
];
KalturaLogger = KalturaLogger_1 = __decorate([
    Injectable(),
    __param(0, Inject(KalturaLoggerName)), __param(0, Optional()), __param(0, Self()),
    __param(1, SkipSelf()), __param(1, Optional()),
    __param(2, Optional()),
    __metadata("design:paramtypes", [String, KalturaLogger,
        KalturaLoggerRecordService])
], KalturaLogger);

var KalturaLoggerModule_1;
if (window && window.onerror) {
    window.onerror = null;
}
let KalturaLoggerModule = KalturaLoggerModule_1 = class KalturaLoggerModule {
    static forRoot(name) {
        return {
            ngModule: KalturaLoggerModule_1,
            providers: [
                KalturaLogger,
                {
                    provide: KalturaLoggerName, useValue: name
                },
                KalturaLoggerRecordService
            ]
        };
    }
};
KalturaLoggerModule = KalturaLoggerModule_1 = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [],
        exports: [],
        providers: []
    })
], KalturaLoggerModule);

/*
 * Public API Surface of kaltura-logger
 */

/**
 * Generated bundle index. Do not edit.
 */

export { KalturaLogger, KalturaLoggerModule, KalturaLoggerName, KalturaLoggerRecordService as Éµa };
//# sourceMappingURL=kaltura-ng-kaltura-logger.js.map

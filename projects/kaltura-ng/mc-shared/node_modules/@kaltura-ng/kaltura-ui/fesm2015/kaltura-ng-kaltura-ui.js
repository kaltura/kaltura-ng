import { __decorate, __metadata } from 'tslib';
import { Renderer2, ViewChild, ElementRef, Input, Component, ViewEncapsulation, NgModule, EventEmitter, Output, ContentChildren, QueryList, HostListener, Directive, Injectable, TemplateRef, ContentChild, HostBinding, ViewChildren, Pipe } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormControl, FormGroup, FormBuilder, Validators, ReactiveFormsModule, NG_VALUE_ACCESSOR } from '@angular/forms';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import 'rxjs/add/observable/fromEvent';
import { cancelOnDestroy, KalturaCommonModule, EmptyLogger } from '@kaltura-ng/kaltura-common';
import { Subject } from 'rxjs/Subject';
import * as $NS from 'jquery';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/forkJoin';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/share';
import 'rxjs/add/operator/map';
import { ReplaySubject } from 'rxjs/ReplaySubject';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/do';
import * as momentNS from 'moment';
import { DomSanitizer } from '@angular/platform-browser';

class AreaBlockerMessage {
    constructor(content) {
        this.title = content.title || 'Error';
        this.message = content.message;
        this.buttons = content.buttons;
    }
}

let AreaBlockerComponent = class AreaBlockerComponent {
    constructor(_renderer) {
        this._renderer = _renderer;
        this.bodyScroll = false;
        this.spinnerMarginTop = 0;
    }
    set showLoader(value) {
        // once showLoader is set to true, use a timeout so *ngIf will cause the HTML to render and then calculate area blocker width
        if (value) {
            this._showLoaderHandler = setTimeout(() => {
                this._showLoaderHandler = null;
                if (this.bodyScroll && !!this.areaBlockerContainer) {
                    const rect = this.areaBlockerContainer.nativeElement.getBoundingClientRect();
                    if (rect.width < document.body.clientWidth && this.spinnerContainer) {
                        this._renderer.setStyle(this.spinnerContainer.nativeElement, 'left', `${rect.left + rect.width / 2}px`);
                    }
                }
                this._renderer.setStyle(this.spinnerContainer.nativeElement, 'opacity', '1'); // show the spinner only after its position is calculated to prevent seeing it jumps...
            }, 0);
        }
        else {
            if (this._showLoaderHandler) {
                clearTimeout(this._showLoaderHandler);
                this._showLoaderHandler = null;
            }
            if (this.bodyScroll && this.spinnerContainer) {
                this._renderer.setStyle(this.spinnerContainer.nativeElement, 'opacity', '0'); // hide the spinner so we won't see it jump next time its position is recalculated
            }
        }
        this._showLoader = value;
    }
    get showLoader() {
        return this._showLoader;
    }
    set message(value) {
        if (typeof value === 'string') {
            this._message = { title: 'Error', message: value, buttons: [{ label: 'Dismiss', action: () => { this._message = null; } }] };
        }
        else if (value instanceof AreaBlockerMessage) {
            this._message = value;
        }
        else {
            this._message = null;
        }
    }
    handleAction(button) {
        if (button) {
            button.action();
        }
    }
    ngOnInit() {
    }
};
AreaBlockerComponent.ctorParameters = () => [
    { type: Renderer2 }
];
__decorate([
    ViewChild('areaBlockerContainer', { static: false }),
    __metadata("design:type", ElementRef)
], AreaBlockerComponent.prototype, "areaBlockerContainer", void 0);
__decorate([
    ViewChild('spinnerContainer', { static: false }),
    __metadata("design:type", ElementRef)
], AreaBlockerComponent.prototype, "spinnerContainer", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], AreaBlockerComponent.prototype, "bodyScroll", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], AreaBlockerComponent.prototype, "spinnerMarginTop", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AreaBlockerComponent.prototype, "classes", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], AreaBlockerComponent.prototype, "showLoader", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], AreaBlockerComponent.prototype, "message", null);
AreaBlockerComponent = __decorate([
    Component({
        selector: 'k-area-blocker',
        template: "<ng-content></ng-content>\n<div #areaBlockerContainer *ngIf=\"showLoader || _message\" class=\"kAreaBlockerContainer\" [class.kAreaBlockerContainerError]=\"_message\" [ngClass]=\"classes\">\n  <div *ngIf=\"showLoader && !_message\" class=\"loading-backdrop show\">\n    <div #spinnerContainer class='spinner-container' [class.bodyScroll]=\"bodyScroll\" [style.marginTop]=\"spinnerMarginTop+'px'\">\n      <div class='spinner'><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></div>\n    </div>\n  </div>\n  <div  class=\"kErrorMessageContainer\" *ngIf=\"_message\" [class.bodyScroll]=\"bodyScroll\">\n    <div class=\"kErrorMessage\">\n      <div class=\"kErrorMessageTitle\">{{ _message.title }}</div>\n      <div class=\"kErrorMessageText\">{{ _message.message }}</div>\n      <div class=\"kErrorButtons\">\n        <button *ngFor=\"let button of _message.buttons\" (click)=\"handleAction(button)\" [ngClass]=\"button.classes\">{{button.label}}</button>\n      </div>\n    </div>\n  </div>\n</div>\n",
        encapsulation: ViewEncapsulation.None,
        styles: ["k-area-blocker{position:relative;width:100%;height:100%;display:flex;flex:1 1 auto}k-area-blocker>.kAreaBlockerContainer{display:flex;flex-direction:row;align-items:center;justify-content:center;width:100%;height:100%;background-color:rgba(255,255,255,.7);position:absolute;top:0;left:0;z-index:510}@-webkit-keyframes kaltura-spinner{0%{transform:rotate(0) scale(.7);opacity:1}100%,70%{transform:rotate(360deg) scale(.7);opacity:1}82%{transform:rotate(360deg) scale(0);opacity:0}87%{transform:rotate(360deg) scale(.9);opacity:1}}@keyframes kaltura-spinner{0%{transform:rotate(0) scale(.7);opacity:1}100%,70%{transform:rotate(360deg) scale(.7);opacity:1}82%{transform:rotate(360deg) scale(0);opacity:0}87%{transform:rotate(360deg) scale(.9);opacity:1}}k-area-blocker>.kAreaBlockerContainer .loading-backdrop{position:absolute;top:0;left:0;width:100%;height:100%}k-area-blocker>.kAreaBlockerContainer .loading-backdrop .spinner-container{display:block;opacity:0;transform:translate3d(-50px,-50px,0)}k-area-blocker>.kAreaBlockerContainer .loading-backdrop .spinner-container.bodyScroll{position:fixed}k-area-blocker>.kAreaBlockerContainer .spinner{width:100px;height:100px;position:relative;-webkit-animation:2.5s infinite kaltura-spinner;animation:2.5s infinite kaltura-spinner}k-area-blocker>.kAreaBlockerContainer .spinner span{width:8px;height:8px;background-color:#fff;display:block;border-radius:8px;position:absolute;top:50%;left:50%;margin-top:-4px;margin-left:-4px}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(1){transform:rotate(45deg) translateX(-25px) translateY(-25px);background-color:#da1f26}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(2){transform:rotate(90deg) translateX(-25px) translateY(-25px);background-color:#06a885}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(3){transform:rotate(135deg) translateX(-25px) translateY(-25px);background-color:#009344}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(4){transform:rotate(180deg) translateX(-25px) translateY(-25px);background-color:#f8a61a}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(5){transform:rotate(225deg) translateX(-25px) translateY(-25px);background-color:#1b4a97}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(6){transform:rotate(270deg) translateX(-25px) translateY(-25px);background-color:#00abcc}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(7){transform:rotate(315deg) translateX(-25px) translateY(-25px);background-color:#b1d238}k-area-blocker>.kAreaBlockerContainer .spinner span:nth-child(8){transform:rotate(360deg) translateX(-25px) translateY(-25px);background-color:#fcd203}k-area-blocker>.kAreaBlockerContainer .kErrorMessageContainer{display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:1001}k-area-blocker>.kAreaBlockerContainer .kErrorMessageContainer.bodyScroll{margin-top:0;position:fixed;top:calc(50vh - 90px);left:calc(50vw - 293px)}k-area-blocker>.kAreaBlockerContainer .kErrorMessage{width:586px;background-color:#fff;border-radius:4px;box-shadow:0 16px 20px 0 rgba(0,0,0,.3);padding:60px 32px 32px;box-sizing:border-box;text-align:center}k-area-blocker>.kAreaBlockerContainer .kErrorMessageTitle{color:#333;font-size:20px;font-weight:700;line-height:24px}k-area-blocker>.kAreaBlockerContainer .kErrorMessageText{max-height:250px;min-height:30px;padding:4px;overflow-y:auto;color:#999;font-size:15px;font-weight:700;line-height:18px;margin-top:26px;white-space:pre-wrap}k-area-blocker>.kAreaBlockerContainer .kErrorButtons{margin-top:44px}k-area-blocker>.kAreaBlockerContainer .kErrorButtons button{cursor:pointer;min-width:100px;outline:0;color:#333;font-size:14px;font-weight:700;line-height:17px;text-align:center;height:34px;border:1px solid #ccc;border-radius:3px;background-color:#fff;box-sizing:border-box;padding:0 12px;margin:0 8px}"]
    }),
    __metadata("design:paramtypes", [Renderer2])
], AreaBlockerComponent);

let AreaBlockerModule = class AreaBlockerModule {
};
AreaBlockerModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [
            AreaBlockerComponent
        ],
        exports: [
            AreaBlockerComponent
        ],
        providers: []
    })
], AreaBlockerModule);

let DetailInfoComponent = class DetailInfoComponent {
    constructor() {
        this.toolTipAsHTML = true;
        this.separator = "|";
        this.maxItemWidth = 300;
        this.isLastItem = false;
        this.itemClick = new EventEmitter();
        this.isClickable = false;
    }
    _setData(data) {
        this._data = data;
    }
    ngOnInit() {
        this.isClickable = this.itemClick.observers.length > 0;
    }
    onClick($event) {
        if (this.isClickable) {
            this.itemClick.emit($event);
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], DetailInfoComponent.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DetailInfoComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DetailInfoComponent.prototype, "valueField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DetailInfoComponent.prototype, "link", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DetailInfoComponent.prototype, "tooltip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DetailInfoComponent.prototype, "toolTipAsHTML", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DetailInfoComponent.prototype, "iconStyle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DetailInfoComponent.prototype, "separator", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], DetailInfoComponent.prototype, "maxItemWidth", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DetailInfoComponent.prototype, "isLastItem", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], DetailInfoComponent.prototype, "itemClick", void 0);
DetailInfoComponent = __decorate([
    Component({
        selector: 'kDetailInfo',
        template: "<div class=\"kDetailInfo\" *ngIf=\"_data\">\n    <div class=\"kDetails\" [style.maxWidth]=\"maxItemWidth+'px'\">\n        <div *ngIf=\"iconStyle\" [kTooltip]=\"tooltip\" class=\"{{iconStyle}} kIcon\"></div>\n        <span class=\"kLabel\" *ngIf=\"label\">{{label}}</span>\n        <span *ngIf=\"!link && (value || valueField)\" [kTooltip]=\"tooltip\" [escape]=\"toolTipAsHTML\" [class.link]=\"isClickable\" (click)=\"onClick($event)\">{{value || _data[valueField]}}</span>\n        <a *ngIf=\"link\" [href]=\"link\" [target]=\"'_blank'\" [kTooltip]=\"tooltip\" class=\"link\">{{link}}</a>\n    </div>\n    <div *ngIf=!isLastItem class=\"kSeparator\">{{separator}}</div>\n</div> ",
        styles: [".kDetailInfo{display:flex;line-height:26px;height:26px}.kDetailInfo .kDetails{display:flex;overflow:hidden}.kDetailInfo .kDetails>a,.kDetailInfo .kDetails>div,.kDetailInfo .kDetails>span{flex:0 0 auto;line-height:26px}.kDetailInfo .kSeparator{padding-right:8px;padding-left:8px;flex:0 0 auto;color:#ccc}.kDetailInfo .kIcon{font-size:16px}.kDetailInfo .kLabel{margin-right:4px}.kDetailInfo .link{font-size:15px;color:#1b4a97;text-decoration:underline;cursor:pointer;text-overflow:ellipsis}.kDetailInfo .link:hover{color:#13356c}.kDetailInfo .link:active{color:#1b4a97}.kDetailInfo .link:disabled{cursor:none;color:#ccc}"]
    }),
    __metadata("design:paramtypes", [])
], DetailInfoComponent);

let DetailsBarComponent = class DetailsBarComponent {
    constructor() {
        this.basicDetailsLabel = "Basic Details";
        this.moreDetailsLabel = "More Details";
        this._shouldUpdateItems = false;
        this._showMore = false;
        this._showBasic = false;
        this.lineScroll = 0;
        this.disableScroll = false;
    }
    set data(dataObj) {
        this._data = dataObj;
        this._shouldUpdateItems = true;
        this.reset();
    }
    onWindowResize() {
        this.reset();
    }
    ngAfterViewChecked() {
        if (this._shouldUpdateItems) {
            this._shouldUpdateItems = false;
            setTimeout(() => {
                this.items.forEach(item => {
                    item._setData(this._data);
                });
            }, 0);
        }
    }
    ngAfterContentInit() {
        this.updateLayout();
        this._itemsChangesSubscription = this.items.changes.subscribe(changes => {
            this._shouldUpdateItems = true;
        });
    }
    _updateItems() {
        if (this.items) {
            this.items.forEach(item => item._setData(this._data));
        }
    }
    updateLayout() {
        //we use a cancelable interval to improve performances on window resize
        if (this.showMoreCheckIntervalID) {
            clearInterval(this.showMoreCheckIntervalID);
            this.showMoreCheckIntervalID = null;
        }
        this.showMoreCheckIntervalID = setTimeout(() => {
            this.items.forEach(item => {
                item.isLastItem = false;
            });
            this.items.last.isLastItem = true;
            const marginTop = parseInt(window.getComputedStyle(this.dataWrapper.nativeElement).top);
            const elementHeight = this.dataWrapper.nativeElement.children.length ? this.dataWrapper.nativeElement.children[0].clientHeight : 0;
            this._showMore = this.dataWrapper.nativeElement.clientHeight > this.dataPanel.nativeElement.getBoundingClientRect().height && Math.abs(marginTop) < (this.dataWrapper.nativeElement.clientHeight + marginTop);
            this._showBasic = this.dataWrapper.nativeElement.clientHeight > this.dataPanel.nativeElement.getBoundingClientRect().height && marginTop < 0;
            // code to remove last separators in each line
            let topArr = [];
            if (this.dataWrapper.nativeElement.children.length) {
                for (let i = 0; i < this.dataWrapper.nativeElement.children.length; i++) {
                    const elm = this.dataWrapper.nativeElement.children[i];
                    const top = elm.getBoundingClientRect().top;
                    topArr.push(top);
                }
                for (let i = 0; i < topArr.length - 1; i++) {
                    if (topArr[i] < topArr[i + 1] && this.items.length >= i) {
                        this.items.forEach((item, index) => {
                            if (i === index) {
                                item.isLastItem = true;
                            }
                        });
                    }
                }
            }
            this.showMoreCheckIntervalID = null;
        }, 100);
    }
    show(direction) {
        if (!this.disableScroll) {
            this.disableScroll = true;
            if (direction === "more") {
                this.lineScroll++;
            }
            else {
                this.lineScroll--;
            }
            this.dataWrapper.nativeElement.style.top = this.dataWrapper.nativeElement.children[0].clientHeight * (-1) * this.lineScroll + "px";
            setTimeout(() => {
                this.updateLayout(); // allow animation to finish before recalculating
                this.disableScroll = false;
            }, 350);
        }
    }
    reset() {
        this.lineScroll = 0;
        this.dataWrapper.nativeElement.style.top = "0px";
        setTimeout(() => {
            this.updateLayout(); // allow animation to finish before recalculating
        }, 350);
    }
    ngOnDestroy() {
        if (this._itemsChangesSubscription) {
            this._itemsChangesSubscription.unsubscribe();
            this._itemsChangesSubscription = null;
        }
    }
};
__decorate([
    ContentChildren(DetailInfoComponent),
    __metadata("design:type", QueryList)
], DetailsBarComponent.prototype, "items", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DetailsBarComponent.prototype, "basicDetailsLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DetailsBarComponent.prototype, "moreDetailsLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], DetailsBarComponent.prototype, "data", null);
__decorate([
    ViewChild('dataPanel', { static: true }),
    __metadata("design:type", ElementRef)
], DetailsBarComponent.prototype, "dataPanel", void 0);
__decorate([
    ViewChild('dataWrapper', { static: true }),
    __metadata("design:type", ElementRef)
], DetailsBarComponent.prototype, "dataWrapper", void 0);
__decorate([
    HostListener("window:resize", []),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], DetailsBarComponent.prototype, "onWindowResize", null);
DetailsBarComponent = __decorate([
    Component({
        selector: 'k-details-bar',
        template: "<div class=\"kContent kDetailsBar\" #dataPanel>\n    <i class=\"kLink kIcondropdown_arrow_bottom\" [class.disabled]=\"!_showMore\" [class.hidden]=\"!_showMore && !_showBasic\" (click)=\"show('more')\"></i>\n    <i class=\"kLink kIcondropdown_arrow_top\" [class.disabled]=\"!_showBasic\" [class.hidden]=\"!_showMore && !_showBasic\" (click)=\"show('basic')\"></i>\n    <div class=\"kItemsWrapper\" #dataWrapper>\n        <ng-content *ngIf=\"_data\" ></ng-content>\n    </div>\n</div>",
        styles: [".kDetailsBar{display:block;height:26px;line-height:26px;overflow-y:hidden;font-size:14px;color:#666}.kDetailsBar .kLink{font-size:14px;float:right;margin-left:8px;border:0;cursor:pointer;margin-top:5px}.kDetailsBar .kLink.disabled{opacity:.4;pointer-events:none}.kDetailsBar .kLink.hidden{opacity:0;pointer-events:none}.kDetailsBar .kItemsWrapper{position:relative;flex:1 1 auto;height:auto;display:flex;flex-flow:wrap;transition:top .3s}"]
    }),
    __metadata("design:paramtypes", [])
], DetailsBarComponent);

let KTooltipDirective = class KTooltipDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this._tooltipElement = null;
        this._tooltipContent = null;
        this._shouldBeVisible = false;
        this._tooltipHeight = null;
        this._tooltipWidth = null;
        this.tooltipResolver = null;
        this.escape = true;
        this.tooltipOffset = 8;
        this.placement = "top";
        this.delay = 300;
        this.maxWidth = 300;
        this.followTarget = false;
        this.showOnEllipsis = false;
    }
    set kTooltip(value) {
        if (this.isValidContent(value)) {
            this._tooltipContent = value;
        }
        else {
            this._tooltipContent = null;
        }
        this._updateTooltipElement();
    }
    isValidContent(value) {
        return typeof value !== 'undefined' && value !== '' && value !== null;
    }
    _updateTooltipElement() {
        if (!this._tooltipContent) {
            if (this._isShowingTooltip()) {
                this._removeTooltipElement();
            }
        }
        else if (this._shouldBeVisible) {
            if (!this._isShowingTooltip()) {
                this._tooltipElement = document.createElement('span');
                this._tooltipElement.style.pointerEvents = 'none';
                this._tooltipElement.className += "ng-tooltip ng-tooltip-" + this.placement;
                if (this.maxWidth > 0) {
                    this._tooltipElement.style.maxWidth = this.maxWidth + "px";
                }
                const addTooltipVisibleClass = () => {
                    if (this._tooltipElement) {
                        this._tooltipElement.className += " ng-tooltip-show";
                    }
                };
                if (this.delay) {
                    setTimeout(addTooltipVisibleClass, this.delay);
                }
                else {
                    addTooltipVisibleClass();
                }
                document.body.appendChild(this._tooltipElement);
                if (this._updateTooltipElementContent()) {
                    this._updateTooltipElementPosition();
                }
            }
            else {
                if (this._updateTooltipElementContent()) {
                    this._updateTooltipElementPosition();
                }
            }
        }
        else {
            if (this._isShowingTooltip()) {
                this._removeTooltipElement();
            }
        }
    }
    onMouseMove() {
        if (this.followTarget) {
            this._updateTooltipElementPosition();
        }
    }
    onMouseEnter() {
        if (!this.showOnEllipsis || this.isInEllipsis()) {
            this._shouldBeVisible = true;
            this._updateTooltipElement();
        }
    }
    onMouseLeave() {
        this._shouldBeVisible = false;
        this._updateTooltipElement();
    }
    isInEllipsis() {
        // added the -1 threshold to support IE and edge which always show a 1px difference between offsetWidth and scrollWidth
        return this.elementRef.nativeElement.offsetWidth < (this.elementRef.nativeElement.scrollWidth - 1);
    }
    _removeTooltipElement() {
        if (this._tooltipElement) {
            if (this._tooltipElement.parentNode) {
                this._tooltipElement.parentNode.removeChild(this._tooltipElement);
            }
            this._tooltipElement = null;
            this._tooltipHeight = null;
            this._tooltipWidth = null;
        }
    }
    _isShowingTooltip() {
        return this._tooltipElement !== null;
    }
    _updateTooltipElementContent() {
        if (this._isShowingTooltip() && this._tooltipContent) {
            let content = '';
            if (this.tooltipResolver && typeof this.tooltipResolver === 'string') {
                content = this._tooltipContent[this.tooltipResolver];
            }
            else if (this.tooltipResolver && typeof this.tooltipResolver === 'function') {
                content = this.tooltipResolver(this._tooltipContent);
            }
            else {
                content = this._tooltipContent;
            }
            if (this.isValidContent(content)) {
                // re-check content type to handle scenarios when the tooltipResolver caused the value to be undefined
                this._tooltipElement.innerHTML = '';
                this._tooltipElement.textContent = '';
                if (this.escape) {
                    this._tooltipElement.textContent = content;
                }
                else {
                    this._tooltipElement.innerHTML = content;
                }
                this._tooltipHeight = this._tooltipElement.clientHeight;
                this._tooltipWidth = this._tooltipElement.offsetWidth;
                return true;
            }
            else {
                this._removeTooltipElement();
                return false;
            }
        }
    }
    _updateTooltipElementPosition() {
        if (this._isShowingTooltip()) {
            const elemPosition = this.elementRef.nativeElement.getBoundingClientRect();
            if (elemPosition) {
                let elemHeight = this.elementRef.nativeElement.offsetHeight;
                let elemWidth = this.elementRef.nativeElement.offsetWidth;
                if (this.placement == 'top') {
                    this._tooltipElement.style.top = elemPosition.top - (this._tooltipHeight + this.tooltipOffset) + 'px';
                }
                if (this.placement == 'bottom') {
                    this._tooltipElement.style.top = elemPosition.top + elemHeight + this.tooltipOffset + 'px';
                }
                if (this.placement == 'top' || this.placement == 'bottom') {
                    this._tooltipElement.style.left = (elemPosition.left + elemWidth / 2) - this._tooltipWidth / 2 + 'px';
                }
                if (this.placement == 'left') {
                    this._tooltipElement.style.left = elemPosition.left - this._tooltipWidth - this.tooltipOffset + 'px';
                }
                if (this.placement == 'right') {
                    this._tooltipElement.style.left = elemPosition.left + elemWidth + this.tooltipOffset + 'px';
                }
                if (this.placement == 'left' || this.placement == 'right') {
                    this._tooltipElement.style.top = elemPosition.top + elemHeight / 2 - this._tooltipElement.clientHeight / 2 + 'px';
                }
                // correct left positioning of tooltip if outside the screen
                const offsetLeft = parseInt(this._tooltipElement.style.left);
                if (offsetLeft < 0) {
                    this._tooltipElement.style.left = 0 + 'px';
                }
            }
        }
        else {
            this._updateTooltipElement();
        }
    }
    ngOnDestroy() {
        this._removeTooltipElement();
    }
};
KTooltipDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], KTooltipDirective.prototype, "tooltipResolver", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], KTooltipDirective.prototype, "escape", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], KTooltipDirective.prototype, "tooltipOffset", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], KTooltipDirective.prototype, "placement", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], KTooltipDirective.prototype, "delay", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], KTooltipDirective.prototype, "maxWidth", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], KTooltipDirective.prototype, "followTarget", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], KTooltipDirective.prototype, "showOnEllipsis", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], KTooltipDirective.prototype, "kTooltip", null);
__decorate([
    HostListener("mousemove"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], KTooltipDirective.prototype, "onMouseMove", null);
__decorate([
    HostListener("mouseenter"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], KTooltipDirective.prototype, "onMouseEnter", null);
__decorate([
    HostListener("mouseleave"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], KTooltipDirective.prototype, "onMouseLeave", null);
KTooltipDirective = __decorate([
    Directive({
        selector: '[kTooltip]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], KTooltipDirective);

let TooltipModule = class TooltipModule {
};
TooltipModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [
            KTooltipDirective
        ],
        exports: [
            KTooltipDirective
        ]
    })
], TooltipModule);

let DetailsBarModule = class DetailsBarModule {
};
DetailsBarModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            TooltipModule
        ],
        declarations: [
            DetailsBarComponent,
            DetailInfoComponent
        ],
        exports: [
            DetailsBarComponent,
            DetailInfoComponent
        ],
        providers: []
    })
], DetailsBarModule);

;
class DynamicFormControlBase {
    constructor(options) {
        this.defaultValue = options.value;
        this.key = options.key || '';
        this.label = options.label || '';
        this.allowMultiple = !!options.allowMultiple;
        this.order = options.order === undefined ? 1 : options.order;
        this.description = options.description || '';
        this.validators = options.validators;
        this.validateOn = options.validateOn || 'change';
        this.errors = options.errors;
        this.inputHelperConfig = options.inputHelperConfig;
        this.styleClass = options.styleClass;
        this.dateFormat = options.dateFormat;
    }
}

class DynamicSectionControl extends DynamicFormControlBase {
    constructor(options) {
        super(options);
        this.children = options.children;
    }
    get controlType() {
        return 'Group';
    }
}

let DynamicFormService = class DynamicFormService {
    constructor(_formBuilder) {
        this._formBuilder = _formBuilder;
    }
    toFormGroup(dynamicControls, config = {}) {
        let result = {};
        if (dynamicControls) {
            dynamicControls.forEach(formControl => {
                if (!config.ignoreMultiple && formControl.allowMultiple) {
                    const formArray = result[formControl.key] = this._formBuilder.array([]);
                    if (config && config.formValue) {
                        // build array formGroup item for each actual record in array
                        const arrayItems = config.formValue[formControl.key];
                        if (arrayItems instanceof Array) {
                            arrayItems.forEach(arrayItem => {
                                formArray.push(this.toFormGroup([formControl], {
                                    ignoreMultiple: true,
                                    formValue: arrayItem
                                }));
                            });
                        }
                    }
                }
                else {
                    if (formControl instanceof DynamicSectionControl) {
                        const shouldCreateNestedGroup = dynamicControls.length > 1;
                        if (shouldCreateNestedGroup) {
                            result[formControl.key] = this.toFormGroup(formControl.children, { formValue: config.formValue });
                        }
                        else {
                            result = this.toFormGroup(formControl.children, { formValue: config.formValue });
                        }
                    }
                    else {
                        result[formControl.key] = new FormControl(formControl.defaultValue || null, { validators: formControl.validators, updateOn: formControl.validateOn ? formControl.validateOn : 'change' });
                    }
                }
            });
        }
        return (result instanceof FormGroup) ? result : this._formBuilder.group(result);
    }
};
DynamicFormService.ctorParameters = () => [
    { type: FormBuilder }
];
DynamicFormService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [FormBuilder])
], DynamicFormService);

let DynamicFormItem = class DynamicFormItem {
    constructor(_formBuilder, _dynamicFormService) {
        this._formBuilder = _formBuilder;
        this._dynamicFormService = _dynamicFormService;
    }
    asDynamicSection(control) {
        return control;
    }
    asFormGroup(control) {
        return control;
    }
    ngOnInit() {
        this.isRequired = false;
        const validators = this.control.validators;
        if (this.control.validators) {
            const RequiredValidator = validators.find(validator => validator == Validators.required);
            if (RequiredValidator) {
                this.isRequired = true;
            }
        }
    }
    initItem(dynamicControl) {
        return this._dynamicFormService.toFormGroup([dynamicControl], { ignoreMultiple: true });
    }
    addItem(dynamicControl) {
        const control = this.form.controls[dynamicControl.key];
        control.push(this.initItem(dynamicControl));
        control.markAsDirty();
    }
    removeItem(dynamicControl, i) {
        const control = this.form.controls[dynamicControl.key];
        control.removeAt(i);
        control.markAsDirty();
    }
};
DynamicFormItem.ctorParameters = () => [
    { type: FormBuilder },
    { type: DynamicFormService }
];
__decorate([
    Input(),
    __metadata("design:type", DynamicFormControlBase)
], DynamicFormItem.prototype, "control", void 0);
__decorate([
    Input(),
    __metadata("design:type", FormGroup)
], DynamicFormItem.prototype, "form", void 0);
__decorate([
    ContentChildren(TemplateRef, { descendants: false }),
    __metadata("design:type", QueryList)
], DynamicFormItem.prototype, "_templates", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], DynamicFormItem.prototype, "labelTemplate", void 0);
DynamicFormItem = __decorate([
    Component({
        selector: 'k-dynamic-form-item',
        template: "<div *ngIf=\"control\" [formGroup]=\"form\">\n\n    <ng-container  *ngIf=\"control.controlType === 'Group' && control.allowMultiple\">\n            <div class=\"kMultiple\" [formArrayName]=\"control.key\">\n                <span class=\"kGroupTitle\" *ngIf=\"control.label\">\n                    <span [kTooltip]=\"control.description\">{{control.label}}</span>\n                </span>\n                <div class=\"kGroupContainer\"  *ngFor=\"let groupForm of asFormGroup(form.controls[control.key]).controls; let i=index\">\n\n                    <div [formGroupName]=\"i\">\n                        <k-dynamic-form-item *ngFor=\"let childControl of asDynamicSection(control).children\"\n                                          [control]=\"childControl\"\n                                          [form]=\"groupForm\">\n                            <ng-template let-item=\"item\">\n                                <ng-container *ngTemplateOutlet=\"_templates.first;context:{ item : item }\">\n                                </ng-container>\n                            </ng-template>\n                        </k-dynamic-form-item>\n                    </div>\n\n                    <div class=\"kDeleteGroup\">\n                        <a (click)=\"!form.disabled && removeItem(control,i)\" [class.disabled]=\"form.disabled\">Delete</a>\n                    </div>\n                </div>\n\n                <div class=\"kGroupButtons\">\n                    <button (click)=\"addItem(control)\" class=\"kButton\" [disabled]=\"form.disabled\">Add</button>\n                </div>\n            </div>\n    </ng-container>\n\n    <div class=\"kMultiple\" *ngIf=\"control.controlType === 'Group' && !control.allowMultiple\">\n        <span class=\"kGroupTitle\" *ngIf=\"control.label\">\n            <span [kTooltip]=\"control.description\">{{control.label}}</span>\n        </span>\n        <k-dynamic-form-item *ngFor=\"let childControl of asDynamicSection(control).children\" [control]=\"childControl\" [form]=\"form\" [labelTemplate]=\"labelTemplate\">\n            <ng-template let-item=\"item\">\n                <ng-container *ngTemplateOutlet=\"_templates.first;context:{ item : item }\"></ng-container>\n            </ng-template>\n        </k-dynamic-form-item>\n    </div>\n\n    <div class=\"kRow\" [ngClass]=\"control.styleClass\" *ngIf=\"control.controlType !== 'Group'\">\n        <div class=\"kFormLabelContainer\">\n            <span class=\"kLabel\" *ngIf=\"control.label && !!labelTemplate == false\">{{control.label}}\n                <kInputHelper *ngIf=\"control.inputHelperConfig && control.inputHelperConfig.body\" [title]=\"control.inputHelperConfig.title\">\n                    <span [innerHTML]=\"control.inputHelperConfig.body\"></span>\n                </kInputHelper>\n            </span>\n            <ng-container *ngIf=\"!!labelTemplate\">\n                <ng-container *ngTemplateOutlet=\"labelTemplate;context:{item: { control : control, form : form, isRequired : isRequired }}\"></ng-container>\n            </ng-container>\n            <span *ngIf=\"isRequired\" class=\"kFormRequiredIndicator\">*</span>\n        </div>\n        <div class=\"kMultiple\" *ngIf=\"control.allowMultiple\" [formArrayName]=\"control.key\">\n\n            <div class=\"kSingleItem\" *ngFor=\"let itemFormGroup of asFormGroup(form.controls[control.key]).controls; let i=index\" [formGroupName]=\"i\">\n                    <ng-container *ngTemplateOutlet=\"_templates.first;context:{item: { control : control, form : itemFormGroup }}\"></ng-container>\n                <a (click)=\"!form.disabled && removeItem(control,i)\" class=\"kDelete\" [class.disabled]=\"form.disabled\">Delete</a>\n            </div>\n            <div>\n                <button class=\"kButton\" (click)=\"!form.disabled && addItem(control)\" [disabled]=\"form.disabled\">Add</button>\n            </div>\n        </div>\n\n        <div class=\"kControl\" [ngClass]=\"[control.controlType, control.key + 'Control']\" *ngIf=\"!control.allowMultiple\">\n            <ng-container *ngTemplateOutlet=\"_templates.first;context:{item: { control : control, form : form }}\"></ng-container>\n        </div>\n        <!--<div class=\"errorMessage\" *ngIf=\"form.controls[control.key].valid\">{{control.label}} is required</div>-->\n    </div>\n</div>\n\n",
        styles: [""]
    }),
    __metadata("design:paramtypes", [FormBuilder, DynamicFormService])
], DynamicFormItem);

class PopupWidgetLayout {
    constructor() { }
    static getPopupZindex(isFullScreen = false) {
        if (isFullScreen) {
            return 1000;
        }
        PopupWidgetLayout.popupWidgetInitialZindex += 2;
        return PopupWidgetLayout.popupWidgetInitialZindex;
    }
    static increaseModalCount() {
        PopupWidgetLayout.modalsCount++;
        if (PopupWidgetLayout.modalsCount === 1) {
            document.body.classList.add("kModal");
        }
    }
    static decreaseModalCount() {
        PopupWidgetLayout.modalsCount--;
        if (PopupWidgetLayout.modalsCount === 0) {
            document.body.classList.remove("kModal");
        }
        if (PopupWidgetLayout.modalsCount < 0) {
            PopupWidgetLayout.modalsCount = 0;
        }
    }
}
PopupWidgetLayout.popupWidgetInitialZindex = 600;
PopupWidgetLayout.modalsCount = 0;

const PopupWidgetStates = {
    "Open": "open",
    "BeforeClose": "beforeClose",
    "Close": "close",
    "Disabled": "disabled"
};
const WINDOW_GUTTER = 16;
let PopupWidgetComponent = class PopupWidgetComponent {
    constructor(popup, renderer) {
        this.popup = popup;
        this.renderer = renderer;
        this.transparent = false;
        this.popupHeight = 'auto';
        this.showTooltip = false;
        this.preventPageScroll = false;
        this.modal = false;
        this.slider = false;
        this.fullScreen = false;
        this.closeBtn = true;
        this.closeBtnInside = false;
        this.closeOnClickOutside = true;
        this.closeOnResize = false;
        this.closeOnBrowserNav = true;
        this.targetOffset = { 'x': 0, 'y': 0 };
        this.childrenPopups = [];
        this.trigger = 'click';
        this.placement = { x: 'right', y: 'bottom' };
        this.closeOnScroll = false;
        this.opened = false;
        this.closed = false;
        this._toggleFunc = this.toggle.bind(this);
        this._openFunc = this.open.bind(this);
        this._closeFunc = this.close.bind(this);
        this._viewInitialize = false;
        this.onOpen = new EventEmitter();
        this.onClose = new EventEmitter();
        this._stateChangeSubscription = null;
        this._statechange = new BehaviorSubject({ state: '' });
        this.state$ = this._statechange.asObservable();
        this._statechange.next({ state: PopupWidgetStates.Close });
        this.state$
            .pipe(cancelOnDestroy(this))
            .subscribe(({ state }) => {
            this.closed = state === PopupWidgetStates.Close;
            this.opened = state === PopupWidgetStates.Open;
        });
    }
    set targetRef(targetRef) {
        if (this.trigger === 'click') {
            if (this._targetRef) {
                this._targetRef.removeEventListener('click', this._toggleFunc);
            }
            this._targetRef = targetRef;
            if (this._targetRef) {
                this._targetRef.addEventListener('click', this._toggleFunc);
            }
        }
        else if (this.trigger === 'hover') {
            if (this._targetRef) {
                this._targetRef.removeEventListener('mouseover', this._openFunc);
                this._targetRef.removeEventListener('mouseout', this._closeFunc);
            }
            this._targetRef = targetRef;
            if (this._targetRef) {
                this._targetRef.addEventListener('mouseover', this._openFunc);
                this._targetRef.addEventListener('mouseout', this._closeFunc);
            }
        }
    }
    get targetRef() { return this._targetRef; }
    set parentPopup(parentPopup) {
        this._parentPopup = parentPopup;
        if (this._stateChangeSubscription) {
            this._stateChangeSubscription.unsubscribe();
            this._stateChangeSubscription = null;
        }
        if (this._parentPopup) {
            this._stateChangeSubscription = this._parentPopup.state$.subscribe(event => {
                if (event.state === PopupWidgetStates.Close) {
                    this.close();
                }
            });
        }
    }
    get parentPopup() { return this._parentPopup; }
    // public API methods
    open() {
        if (this.isEnabled && this.validate()) {
            // handle auto height
            if (!this.popupHeight || this.popupHeight === 'auto') {
                if (this.slider) {
                    this._popupWidgetHeight = 'calc(100vh - 80px)';
                }
                else {
                    this._popupWidgetHeight = 'auto';
                }
            }
            else {
                this._popupWidgetHeight = this.popupHeight + "px";
            }
            this._saveScrollPosition = window.pageYOffset || document.documentElement.scrollTop;
            // set location according to targetRef
            const parentLeft = this.appendTo && !this.modal ? this.appendTo.getBoundingClientRect().left : 0;
            const parentTop = this.appendTo && !this.modal ? this.appendTo.getBoundingClientRect().top : 0;
            // center on screen if no targetRef was defined
            if (!this._targetRef) {
                if (this.fullScreen) {
                    this.modal = false;
                    this.preventPageScroll = true;
                    this.renderer.addClass(this.popup.nativeElement, 'fullScreen');
                }
                else {
                    this.popup.nativeElement.style.marginLeft = window.innerWidth / 2 - this.popupWidth / 2 + 'px';
                    if (this.slider) {
                        window.scrollTo(0, 0);
                        this.popup.nativeElement.style.top = "auto";
                        this.closeBtn = false;
                        this.preventPageScroll = true;
                        this.popup.nativeElement.style.bottom = this.popupHeight !== 'auto' ? this.popupHeight * -1 + "px" : "-1000px";
                        setTimeout(() => {
                            this.popup.nativeElement.style.bottom = 0 + "px"; // use timeout to invoke animation
                        }, 0);
                    }
                    else {
                        const marginTop = (window.innerHeight / 2 - 100 / 2);
                        this.popup.nativeElement.style.marginTop = marginTop + 'px';
                        this.popup.nativeElement.style.position = "fixed";
                    }
                }
            }
            else {
                this.popup.nativeElement.style.marginLeft = this._targetRef.getBoundingClientRect().left - parentLeft + this.targetOffset['x'] + 'px';
                this.popup.nativeElement.style.marginTop = this._targetRef.getBoundingClientRect().top - parentTop + this.targetOffset['y'] + 'px';
                this.popup.nativeElement.style.position = "absolute";
            }
            this.popup.nativeElement.style.zIndex = PopupWidgetLayout.getPopupZindex(this.fullScreen);
            // handle modal
            if (!this._modalOverlay) {
                if (this.trigger !== 'hover') {
                    this._modalOverlay = document.createElement('div');
                    if (this.modal || this.slider) {
                        this._modalOverlay.className = "kPopupWidgetModalOverlay";
                    }
                    else {
                        this._modalOverlay.className = "kPopupWidgetModalOverlay kTransparent";
                    }
                    this._modalOverlay.style.zIndex = this.popup.nativeElement.style.zIndex - 1;
                    if (!this.slider && this.closeOnClickOutside) {
                        this._modalOverlay.addEventListener("mousedown", (event) => {
                            event.stopPropagation();
                            this.close();
                        });
                    }
                    if (this.appendTo) {
                        this.appendChild(this._modalOverlay, this.appendTo);
                    }
                    else {
                        document.body.appendChild(this._modalOverlay);
                    }
                    if (this.modal || this.slider) {
                        PopupWidgetLayout.increaseModalCount();
                    }
                }
            }
            // prevent page scroll
            if (this.preventPageScroll) {
                document.body.style.overflowY = 'hidden';
                document.body.style.position = 'fixed';
            }
            setTimeout(() => {
                this.addClickOutsideSupport();
            }, 0);
            this.onOpen.emit(); // dispatch onOpen event (API)
            this._statechange.next({ state: PopupWidgetStates.Open });
            if (this.closeOnScroll && this.isShow) {
                window.addEventListener('scroll', this._closeFunc);
            }
        }
        if (!this.slider && !this.fullScreen && this.popup.nativeElement) {
            this.popup.nativeElement.style.opacity = 0;
        }
        // auto positioning need first the dom to render
        setTimeout(() => {
            this.setPosition();
        }, 0);
    }
    close(context = null, reason = null) {
        if (this.isEnabled && this.isShow) {
            window.removeEventListener('scroll', this._closeFunc);
            if (this.fullScreen) {
                this.renderer.removeClass(this.popup.nativeElement, 'fullScreen');
            }
            // allow cancelling the close operation
            let beforeCloseContext = { "allowClose": true };
            this._statechange.next({ state: PopupWidgetStates.BeforeClose, context: beforeCloseContext });
            if (beforeCloseContext['allowClose']) {
                // close children popups if exist
                if (this.childrenPopups.length) {
                    this.childrenPopups.forEach((popup) => {
                        popup.close();
                    });
                }
                this.removeClickOutsideSupport();
                this.restorePageScroll(true);
                this.onClose.emit(); // dispatch onClose event (API)
                let timeout = 0;
                if (this.slider) {
                    this.popup.nativeElement.style.bottom = this.popupHeight !== 'auto' ? this.popupHeight * -1 + "px" : "-1000px";
                    timeout = 300;
                }
                if (this.modal && !this.slider) {
                    PopupWidgetLayout.decreaseModalCount();
                }
                setTimeout(() => {
                    // remove modal
                    if (this._modalOverlay) {
                        if (this.appendTo) {
                            this.removeChild(this._modalOverlay, this.appendTo);
                        }
                        else {
                            document.body.removeChild(this._modalOverlay);
                        }
                        this._modalOverlay = null;
                    }
                    if (this.slider) {
                        PopupWidgetLayout.decreaseModalCount();
                    }
                    this._statechange.next({ state: PopupWidgetStates.Close, context: context, reason: reason }); // use timeout to prevent valueChangeAfterChecked error
                }, timeout);
            }
        }
    }
    toggle() {
        if (this.isEnabled) {
            this.isShow ? this.close() : this.open();
        }
    }
    get isShow() {
        return this._statechange.getValue().state !== PopupWidgetStates.Close;
    }
    get isEnabled() {
        return this._statechange.getValue().state !== PopupWidgetStates.Disabled;
    }
    onWindowResize() {
        if (this.closeOnResize) {
            this.close();
        }
        else {
            this.setPosition();
        }
    }
    onPopState(event) {
        if (this.closeOnBrowserNav) {
            this.close();
        }
    }
    // component lifecycle events
    ngAfterViewInit() {
        this._viewInitialize = true;
        if (this.validate()) {
            if (this.appendTo && !this.modal) {
                this.appendChild(this.popup.nativeElement, this.appendTo);
            }
            else {
                document.body.appendChild(this.popup.nativeElement);
                if (this.appendTo) {
                    console.warn("[kaltura] -> Ignoring append to " + this.appendTo + " since popup is set to modal=true."); // keep warning
                }
            }
            if (this.fullScreen) {
                this.popup.nativeElement.style.width = '0px';
                this.popup.nativeElement.style.height = '0px';
            }
        }
    }
    ngOnDestroy() {
        if (this._targetRef) {
            this._targetRef.removeEventListener('click', this._toggleFunc);
            this._targetRef.removeEventListener('mouseover', this._openFunc);
            this._targetRef.removeEventListener('mouseout', this._closeFunc);
        }
        if (this._stateChangeSubscription) {
            this._stateChangeSubscription.unsubscribe();
        }
        this._statechange.complete();
        this.removeClickOutsideSupport();
        this.restorePageScroll(false);
        if (this.modal && this._modalOverlay) {
            document.body.removeChild(this._modalOverlay);
            this._modalOverlay = null;
        }
        if (this.appendTo && !this.modal) {
            this.removeChild(this.popup.nativeElement, this.appendTo);
        }
        else {
            if (this._viewInitialize) {
                document.body.removeChild(this.popup.nativeElement);
            }
        }
        window.removeEventListener('scroll', this._closeFunc);
    }
    // private methods
    addClickOutsideSupport() {
        if (this.closeOnClickOutside) {
            this.popup.nativeElement.addEventListener('mousedown', this.blockMouseDownHandler);
            if (this.targetRef) {
                this.targetRef.addEventListener('mousedown', this.blockMouseDownHandler);
            }
        }
    }
    blockMouseDownHandler(event) {
        event.stopPropagation();
    }
    removeClickOutsideSupport() {
        if (this.closeOnClickOutside) {
            this.popup.nativeElement.removeEventListener('mousedown', this.blockMouseDownHandler);
            if (this.targetRef) {
                this.targetRef.removeEventListener('mousedown', this.blockMouseDownHandler);
            }
        }
    }
    restorePageScroll(restoreScrollPosition = true) {
        if (this.preventPageScroll) {
            document.body.style.overflowY = 'auto';
            document.body.style.position = '';
            if (restoreScrollPosition) {
                window.scrollTo(0, this._saveScrollPosition);
            }
        }
    }
    validate() {
        let valid = typeof this.popupWidth !== 'undefined' || this.fullScreen;
        if (!valid) {
            this._statechange.next({ state: PopupWidgetStates.Disabled });
            throw "Popup widget error: missing required parameters. Verify popupWidth is defined.";
        }
        return valid;
    }
    appendChild(element, target) {
        if (this.isElement(target)) {
            target.appendChild(element);
        }
        else {
            throw 'Cannot append ' + target + ' to ' + element;
        }
    }
    removeChild(element, target) {
        if (this.isElement(target)) {
            target.removeChild(element);
        }
        else {
            throw 'Cannot remove ' + target + ' from ' + element;
        }
    }
    isElement(obj) {
        return (typeof HTMLElement === "object" ? obj instanceof HTMLElement :
            obj && typeof obj === "object" && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === "string");
    }
    setPosition() {
        const popupHeight = this.popup.nativeElement.clientHeight;
        const popupWidth = this.popup.nativeElement.clientWidth;
        if (this.modal || this.slider) {
            this.popup.nativeElement.style.marginLeft = window.innerWidth / 2 - this.popupWidth / 2 + 'px';
            if (this.modal) {
                const modalMarginTop = (window.innerHeight / 2 -
                    popupHeight / 2);
                this.popup.nativeElement.style.marginTop = Math.round(modalMarginTop) + 'px';
                this.popup.nativeElement.style.opacity = 1;
            }
            return;
        }
        if (!this._targetRef)
            return;
        const popupBox = this.popup.nativeElement.getBoundingClientRect();
        const targetRefBox = this._targetRef.getBoundingClientRect();
        const parentTop = this.appendTo && !this.modal ? this.appendTo.getBoundingClientRect().top : 0;
        const parentLeft = this.appendTo && !this.modal ? this.appendTo.getBoundingClientRect().left : 0;
        let popupMarginTop;
        let popupMarginLeft;
        let popupLeftMargins = {};
        let popupTopMargins = {};
        popupTopMargins.top = (targetRefBox.top
            - parentTop
            - popupHeight
            + this.targetRef.offsetHeight
            - this.targetOffset['y']);
        popupTopMargins.bottom = (targetRefBox.top
            - parentTop
            + this.targetOffset['y']);
        popupTopMargins.center = (targetRefBox.top
            - parentTop
            - popupHeight / 2
            + this.targetRef.offsetHeight / 2
            + this.targetOffset['y']);
        popupLeftMargins.left = (targetRefBox.left
            - parentLeft
            - popupWidth
            + this.targetRef.clientWidth
            - this.targetOffset['x']);
        popupLeftMargins.right = (targetRefBox.left
            - parentLeft
            + this.targetOffset['x']);
        popupLeftMargins.center = (targetRefBox.left
            - parentLeft
            - popupWidth / 2
            + this.targetOffset['x']);
        popupMarginTop = this.placement.y ? popupTopMargins[this.placement.y] : popupTopMargins.bottom;
        popupMarginLeft = this.placement.x ? popupLeftMargins[this.placement.y] : popupLeftMargins.right;
        this.popup.nativeElement.style.marginTop = Math.round(popupMarginTop) + 'px';
        this.popup.nativeElement.style.marginLeft = Math.round(popupMarginLeft) + 'px';
        this.validatePosition(popupLeftMargins, popupTopMargins);
    }
    // validate popup widget is not outside of the viewport (+ gutter) and if it is, reposition it
    validatePosition(popupLeftMargins, popupTopMargins) {
        const popupHeight = this.popup.nativeElement.clientHeight;
        const popupWidth = this.popup.nativeElement.clientWidth;
        const popupBox = this.popup.nativeElement.getBoundingClientRect();
        const clientHeight = window.innerHeight;
        const clientWidth = window.innerWidth;
        let popupMarginTop;
        let popupMarginLeft;
        if (this.placement.y === 'top') {
            if (popupBox.top < WINDOW_GUTTER) {
                popupMarginTop = popupTopMargins.bottom;
            }
        }
        else if (this.placement.y === 'bottom') {
            if (popupBox.top + popupHeight > clientHeight - WINDOW_GUTTER && popupBox.top > clientHeight) {
                popupMarginTop = popupTopMargins.top;
            }
            else {
                popupMarginTop = popupTopMargins.bottom;
            }
        }
        else if (this.placement.y === 'center') {
            if (popupBox.top < WINDOW_GUTTER) {
                popupMarginTop = popupTopMargins.bottom;
            }
            else if (popupBox.top + popupHeight > clientHeight - WINDOW_GUTTER) {
                popupMarginTop = popupTopMargins.top;
            }
        }
        if (popupBox.left + popupWidth > clientWidth + WINDOW_GUTTER) {
            popupMarginLeft = popupLeftMargins.left;
        }
        else if (popupBox.left < WINDOW_GUTTER) {
            popupMarginLeft = popupLeftMargins.right;
        }
        this.popup.nativeElement.style.marginTop = Math.round(popupMarginTop) + 'px';
        this.popup.nativeElement.style.marginLeft = Math.round(popupMarginLeft) + 'px';
        this.popup.nativeElement.style.opacity = 1;
    }
};
PopupWidgetComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], PopupWidgetComponent.prototype, "transparent", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PopupWidgetComponent.prototype, "appendTo", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], PopupWidgetComponent.prototype, "popupWidth", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PopupWidgetComponent.prototype, "popupHeight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PopupWidgetComponent.prototype, "showTooltip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PopupWidgetComponent.prototype, "preventPageScroll", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PopupWidgetComponent.prototype, "modal", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PopupWidgetComponent.prototype, "slider", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PopupWidgetComponent.prototype, "fullScreen", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PopupWidgetComponent.prototype, "closeBtn", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PopupWidgetComponent.prototype, "closeBtnInside", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PopupWidgetComponent.prototype, "closeOnClickOutside", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PopupWidgetComponent.prototype, "closeOnResize", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PopupWidgetComponent.prototype, "closeOnBrowserNav", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PopupWidgetComponent.prototype, "targetOffset", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], PopupWidgetComponent.prototype, "childrenPopups", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], PopupWidgetComponent.prototype, "trigger", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PopupWidgetComponent.prototype, "placement", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PopupWidgetComponent.prototype, "closeOnScroll", void 0);
__decorate([
    ContentChild(TemplateRef, { static: true }),
    __metadata("design:type", TemplateRef)
], PopupWidgetComponent.prototype, "_template", void 0);
__decorate([
    HostBinding('class.opened'),
    __metadata("design:type", Object)
], PopupWidgetComponent.prototype, "opened", void 0);
__decorate([
    HostBinding('class.closed'),
    __metadata("design:type", Object)
], PopupWidgetComponent.prototype, "closed", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], PopupWidgetComponent.prototype, "targetRef", null);
__decorate([
    Input(),
    __metadata("design:type", PopupWidgetComponent),
    __metadata("design:paramtypes", [PopupWidgetComponent])
], PopupWidgetComponent.prototype, "parentPopup", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], PopupWidgetComponent.prototype, "onOpen", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], PopupWidgetComponent.prototype, "onClose", void 0);
__decorate([
    HostListener("window:resize", []),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], PopupWidgetComponent.prototype, "onWindowResize", null);
__decorate([
    HostListener('window:popstate', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], PopupWidgetComponent.prototype, "onPopState", null);
PopupWidgetComponent = __decorate([
    Component({
        selector: 'kPopupWidget',
        template: "<div #container\n     class=\"kPopupWidget\"\n     [class.transparent]=\"transparent\"\n     [class.slider]=\"slider\"\n     [style.display]=\"(state$ | async)?.state !== 'close' ? 'block' : 'none'\"\n     [style.width]=\"popupWidth+'px'\"\n     [style.height]=\"_popupWidgetHeight\">\n    <div class=\"tooltipUp\" *ngIf=\"showTooltip\" [style.marginLeft]=\"popupWidth/2-12+'px'\"></div>\n    <i *ngIf=\"closeBtn\" class=\"kCloseBtn kIconclose_small\" [class.closeBtnInside]=\"closeBtnInside\" (click)=\"close()\"></i>\n    <div class=\"kPopupWidgetContent\" *ngIf=\"isShow\">\n        <ng-content *ngIf=\"!_template\"></ng-content>\n\t\t<ng-template *ngIf=\"_template\"\n\t\t\t[ngTemplateOutlet]=\"_template\">\n\t\t</ng-template>\n    </div>\n</div>\n",
        styles: [":host{position:absolute;left:0;top:0;transition:bottom .3s ease-in-out}:host.fullScreen{width:100%!important;height:100%!important;position:fixed}.kPopupWidget{background-color:#fff;border-radius:4px;box-shadow:0 16px 20px 0 rgba(0,0,0,.3)}.kPopupWidget.slider{border-bottom-right-radius:0;border-bottom-left-radius:0}.kPopupWidget.transparent{box-shadow:none;background:0}.kPopupWidget .kCloseBtn:not(.closeBtnInside){position:absolute;right:-118px;top:-62px;width:38px;height:38px;background-color:rgba(255,255,255,.2);border-radius:50%;text-align:center;padding-top:11px;padding-left:2px;box-sizing:border-box;color:#fff;cursor:pointer}.kPopupWidget .kCloseBtn:not(.closeBtnInside):hover{background-color:rgba(255,255,255,.4)}.kPopupWidget .kCloseBtn.closeBtnInside{font-size:14px;float:right;color:#999;margin-top:14px;margin-right:14px;cursor:pointer}.kPopupWidget .kCloseBtn.closeBtnInside:hover{color:#00a784}.kPopupWidget .tooltipUp{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAOCAYAAAA1+Nx+AAAAAXNSR0IArs4c6QAAAMpJREFUOBGtk0EOwiAQRcF0Z2JXspFTcAE9erkACXfADa50b3DGMAYjlGktSUNDhvfmlyLEguG9V86544ItQnKLEZxSslCfpJQXY8yNs3fHKcrwSSl1gGcE0cRN0k1AnSNca33ChkII1xjjA5Kce0lmE5SdExwF+I5CTpJmggI+lnAU0MhJ7nNnUhVw4FzJj2AJnCP5EmS4LQ+UIL25dfAfwT9wktckb8EW8JZEbgmvSQa8/mu+OcFqM/3WcBntAPA9LdSK165l5vMFmCyyP+zXS30AAAAASUVORK5CYII=);position:absolute;margin-top:-12px;width:24px;height:12px}"]
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], PopupWidgetComponent);

let PopupWidgetModule = class PopupWidgetModule {
};
PopupWidgetModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [
            PopupWidgetComponent
        ],
        exports: [
            PopupWidgetComponent
        ],
        providers: []
    })
], PopupWidgetModule);

let InputHelperComponent = class InputHelperComponent {
    constructor() {
        this.trigger = 'hover';
        this.triggerIcon = 'kIconhelp_full';
        this.icon = 'kIconhelp';
        this.width = 300;
        this.placement = { x: 'right', y: 'top' };
    }
    ngOnInit() { }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], InputHelperComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], InputHelperComponent.prototype, "trigger", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], InputHelperComponent.prototype, "triggerIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], InputHelperComponent.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], InputHelperComponent.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], InputHelperComponent.prototype, "placement", void 0);
InputHelperComponent = __decorate([
    Component({
        selector: 'kInputHelper',
        template: "<div class=\"kInputHelper\" #inputHelperContainer>\n    <a class=\"kIconhelpLink\" [class.kActive]=\"helperPopup.isShow\" #helperLink><i class=\"{{triggerIcon}}\"></i></a>\n\n    <kPopupWidget\n                  #helperPopup\n                  class=\"kInputHelperPopup\"\n                  [appendTo]=\"inputHelperContainer\"\n                  [targetOffset]=\"{x: 0, y: 20}\"\n                  [popupWidth]=\"width\"\n                  [closeBtn]=\"false\"\n                  [trigger]=\"trigger\"\n                  [placement]=\"placement\"\n                  [targetRef]=\"helperLink\">\n\n        <ng-template>\n            <div class=\"kInputHelperContainer kAverageElevation\">\n                <div *ngIf=\"title\" class=\"kInputHelperPopupHeader\">\n                    <i class=\"kIcon {{icon}}\"></i>\n                    {{title}}\n                </div>\n                <div class=\"kInputHelperPopupContent\">\n                    <ng-content></ng-content>\n                </div>\n            </div>\n        </ng-template>\n\n    </kPopupWidget>\n</div>\n",
        styles: [".kInputHelper{display:inline-block;vertical-align:middle;margin-left:6px;position:relative}.kInputHelper .kIconhelpLink{color:#999;text-decoration:none;position:relative;z-index:2}.kInputHelper .kIconhelpLink.kActive,.kInputHelper .kIconhelpLink:hover{color:#01accd}.kInputHelperPopup{border-radius:3px}.kInputHelperPopup ::ng-deep .kPopupWidget{box-shadow:none}.kInputHelperPopup .kInputHelperContainer{font-size:15px;line-height:20px;color:#999;padding:16px;border-radius:3px}.kInputHelperPopup .kInputHelperPopupHeader{color:#333;display:flex;align-items:center;padding-bottom:10px}.kInputHelperPopup .kInputHelperPopupHeader .kIcon{color:#999;font-size:24px;margin-right:14px}"]
    }),
    __metadata("design:paramtypes", [])
], InputHelperComponent);

let InputHelperModule = class InputHelperModule {
};
InputHelperModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            PopupWidgetModule
        ],
        declarations: [
            InputHelperComponent
        ],
        exports: [
            InputHelperComponent
        ],
        providers: []
    })
], InputHelperModule);

let DynamicFormModule = class DynamicFormModule {
};
DynamicFormModule = __decorate([
    NgModule({
        imports: [
            ReactiveFormsModule,
            CommonModule,
            TooltipModule,
            InputHelperModule
        ],
        declarations: [
            DynamicFormItem
        ],
        exports: [
            DynamicFormItem
        ],
        providers: [
            DynamicFormService
        ]
    })
], DynamicFormModule);

class ListControl extends DynamicFormControlBase {
    constructor(options) {
        super(options);
        this.values = options.values;
    }
    get controlType() {
        return 'List';
    }
}

class DatePickerControl extends DynamicFormControlBase {
    constructor(options) {
        super(options);
        this.showTime = false;
        this.showTime = options.showTime;
    }
    get controlType() {
        return 'DatePicker';
    }
}

class TextAreaControl extends DynamicFormControlBase {
    get controlType() {
        return 'TextArea';
    }
    constructor(options) {
        super(options);
    }
}

class TextboxControl extends DynamicFormControlBase {
    get controlType() {
        return 'Textbox';
    }
    constructor(options) {
        super(options);
    }
}

class DynamicDropdownControl extends DynamicFormControlBase {
    constructor(options) {
        super(options);
        this.values = options.values;
    }
    get controlType() {
        return 'Dropdown';
    }
}

class SwitchControl extends DynamicFormControlBase {
    get controlType() {
        return 'Switch';
    }
    constructor(options) {
        super(options);
    }
}

class NumberControl extends DynamicFormControlBase {
    get controlType() {
        return 'Number';
    }
    constructor(options) {
        super(options);
    }
}

let KalturaPlayerComponent = class KalturaPlayerComponent {
    constructor() {
        this.width = 480;
        this.height = 360;
        this.cdnUrl = 'http://cdnapi.kaltura.com';
        this.flashvars = {};
        this.lazy = false;
        this.id = "";
        this.kalturaPlayerReady = new EventEmitter();
    }
    ngAfterViewInit() {
        if (!this.lazy) {
            this.Embed();
        }
    }
    Embed() {
        // validation
        if (!this.pid || !this.uiconfid || !this.entryid) {
            console.warn("Kaltura Player::Missing parameters. Please provide pid, uiconfid and entryid.");
        }
        else {
            // load player lib if doesn't exist
            if (document.getElementById("kalturaPlayerLib") === null) {
                let s = document.createElement('script');
                s.src = `${this.cdnUrl}/p/${this.pid}/sp/${this.pid}00/embedIframeJs/uiconf_id/${this.uiconfid}/partner_id/${this.pid}`;
                s.id = "kalturaPlayerLib";
                s.async = false;
                document.head.appendChild(s);
            }
            // wait for lib to load if not loaded and then embed player
            if (!this.kdp) {
                const intervalID = setInterval(() => {
                    if (typeof window['kWidget'] !== "undefined") {
                        clearInterval(intervalID);
                        this.doEmbed();
                    }
                }, 50);
            }
            else {
                this.doEmbed();
            }
        }
    }
    doEmbed() {
        window['kWidget'].embed({
            "targetId": "kaltura_player_" + this.id,
            "wid": "_" + this.pid,
            "uiconf_id": this.uiconfid,
            "flashvars": this.flashvars,
            "cache_st": Math.random(),
            "entry_id": this.entryid,
            "readyCallback": (playerID) => {
                this.kdp = document.getElementById(playerID);
                this.kalturaPlayerReady.emit(this.kdp);
            }
        });
    }
    ngOnDestroy() {
        if (this.kdp) {
            window['kWidget'].destroy(this.kdp);
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", Number)
], KalturaPlayerComponent.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], KalturaPlayerComponent.prototype, "height", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], KalturaPlayerComponent.prototype, "pid", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], KalturaPlayerComponent.prototype, "uiconfid", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], KalturaPlayerComponent.prototype, "entryid", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], KalturaPlayerComponent.prototype, "cdnUrl", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], KalturaPlayerComponent.prototype, "flashvars", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], KalturaPlayerComponent.prototype, "lazy", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], KalturaPlayerComponent.prototype, "id", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], KalturaPlayerComponent.prototype, "kalturaPlayerReady", void 0);
KalturaPlayerComponent = __decorate([
    Component({
        selector: 'k-player',
        template: "<div id=\"kaltura_player_{{id}}\" [style.width]=\"width+'px'\" [style.height]=\"height+'px'\" class=\"kPlayer\"></div>",
        styles: [".kPlayer{background-color:#000}"]
    }),
    __metadata("design:paramtypes", [])
], KalturaPlayerComponent);

let StickyScrollService = class StickyScrollService {
    constructor() {
        this._scrollSubject = new Subject();
        this.scrollStatus$ = this._scrollSubject.asObservable();
        this._resizeSubject = new Subject();
        this.resizeStatus$ = this._resizeSubject.asObservable();
        this._layoutSubject = new BehaviorSubject({});
        this.layoutSubject$ = this._layoutSubject.asObservable();
        this.stickyElements = {};
        this.manageScrollFunc = this.manageScrollEvent.bind(this);
        this.manageResizeFunc = this.manageResizeEvent.bind(this);
        window.addEventListener('scroll', this.manageScrollFunc);
        window.addEventListener('resize', this.manageResizeFunc);
    }
    ngOnDestroy() {
        window.removeEventListener('scroll', this.manageScrollFunc);
        window.removeEventListener('resize', this.manageResizeFunc);
    }
    manageScrollEvent() {
        this._scrollSubject.next({});
    }
    manageResizeEvent() {
        this._resizeSubject.next({});
    }
    attach(id) {
        if (!id) {
            throw new Error("sticky service::missing id on attach!");
        }
        else if (typeof this.stickyElements[id] !== "undefined") {
            throw new Error("sticky service::id already exists! (" + id + ")");
        }
        else {
            this.stickyElements[id] = null;
        }
    }
    detach(id) {
        if (!id) {
            console.warn("sticky service::missing id on attach!");
        }
        else {
            delete this.stickyElements[id];
        }
    }
    update(id, height, offset) {
        if (!id) {
            console.warn("sticky service::missing id!");
        }
        else {
            const currentValue = this.stickyElements[id];
            if (typeof currentValue !== "undefined") {
                if (currentValue === null || currentValue.height !== height || currentValue.offset !== offset) {
                    this.stickyElements[id] = { height, offset };
                    this._layoutSubject.next(this.stickyElements);
                }
            }
            else {
                throw new Error(`unknown sticky element '${id}' (did you attach it before updating?)`);
            }
        }
    }
};
StickyScrollService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [])
], StickyScrollService);

let StickyDirective = class StickyDirective {
    constructor(elementRef, renderer, _stickyScrollService) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this._stickyScrollService = _stickyScrollService;
        this.lastScroll = 0;
        this.isSticky = false;
        this._destroyed = false;
        this.onStickyEvent = new EventEmitter();
        this.onUnStickyEvent = new EventEmitter();
        this.scrollOffset = 0;
        this.stickyId = "";
        this.sticksTo = "";
        this.elementSelector = "";
        this._parentTop = null;
        this._parentOffset = null;
        this._stickyTop = null;
        this._stickyOffset = null;
    }
    _getStickyElement(elementRef) {
        return elementRef.nativeElement;
    }
    ngAfterViewInit() {
        // console.log(`[${this.stickyId}] - ngAfterViewInit`);
        this._stickyElement = this._getStickyElement(this.elementRef);
        this.update();
    }
    ngOnInit() {
        // console.log(`[${this.stickyId}] - attached`);
        if (this.stickyId) {
            this._stickyScrollService.attach(this.stickyId);
        }
        this._stickyScrollService.scrollStatus$.pipe(cancelOnDestroy(this)).subscribe(event => {
            // console.log(`[${this.stickyId}] - handle scroll`);
            this._render();
        });
        this._stickyScrollService.resizeStatus$.pipe(cancelOnDestroy(this)).subscribe(event => {
            this.onResize();
        });
        this._stickyScrollService.layoutSubject$.pipe(cancelOnDestroy(this)).subscribe(elements => {
            const data = this.sticksTo ? elements[this.sticksTo] : { height: 0, offset: 0 };
            if (data && (this._parentTop !== data.height ||
                this._parentOffset !== data.offset)) {
                this._parentTop = data.height;
                this._parentOffset = data.offset;
                this.update();
            }
        });
    }
    ngOnDestroy() {
        // console.log(`[${this.stickyId}] - destroyed`);
        this._destroyed = true;
        this._stickyScrollService.detach(this.stickyId);
    }
    update() {
        if (this._parentTop !== null
            && this._parentOffset != null) {
            // console.log(`[${this.stickyId}] - handle layout update`);
            const stickyOffset = this._parentOffset + this.scrollOffset;
            if (this._stickyTop !== this._parentTop ||
                this._stickyOffset !== stickyOffset) {
                // console.log(`[${this.stickyId}] - update cached values`);
                this._stickyTop = this._parentTop;
                this._stickyOffset = stickyOffset;
                this._render();
            }
            if (this.stickyId && this._stickyElement) {
                // console.log(`[${this.stickyId}] - update service`);
                const elementHeight = this._stickyElement.getBoundingClientRect()['height'];
                setTimeout(() => {
                    this._stickyScrollService.update(this.stickyId, elementHeight + this._stickyTop, this._stickyOffset);
                }, 0);
            }
        }
    }
    _render() {
        if (!this._destroyed && this._stickyElement) {
            // console.log(`[${this.stickyId}] - _render`);
            if (this._stickyTop !== null
                && this._stickyOffset != null) {
                const scroll = window.pageYOffset;
                if (scroll > this.lastScroll && !this.isSticky && this._stickyElement.getBoundingClientRect()['top'] <= this._stickyTop) {
                    // console.log(`[${this.stickyId}] - _render (set sticky mode)`);
                    this.setSticky();
                }
                else if (scroll < this.lastScroll && this.isSticky && scroll <= this._stickyOffset) {
                    // console.log(`[${this.stickyId}] - _render (unset sticky mode)`);
                    this.unsetSticky();
                }
                else {
                    if (this.isSticky && scroll === this.lastScroll) {
                        this.setStyle('top', this._stickyTop + 'px');
                        // console.log(`[${this.stickyId}] - _render (update sitcky values) - TODO!!!!!!`);
                    }
                }
                this.lastScroll = scroll;
            }
        }
    }
    setSticky() {
        if (!this.isSticky) {
            this.isSticky = true;
            // console.log(`[${this.stickyId}] - top = ${this._stickyElement.clientTop}`);
            this.originalCss = {
                position: this._stickyElement.style.position,
                top: this._stickyElement.clientTop,
                marginTop: this._stickyElement.style.marginTop,
                left: this._stickyElement.clientLeft
            };
            this.setStyle('position', 'fixed');
            this.setStyle('top', this._stickyTop + 'px');
            if (this.appendTo) {
                this.setStyle('left', this.appendTo.getBoundingClientRect()['left'] + 'px');
            }
            this.setClass(true);
            this.onStickyEvent.emit();
            this._onSticky();
        }
    }
    _onSticky() {
        setTimeout(() => { this.update(); }, 0);
    }
    unsetSticky() {
        if (this.isSticky) {
            this.isSticky = false;
            this.setStyle('position', this.originalCss.position);
            this.setStyle('marginTop', this.originalCss.marginTop);
            this.setStyle('top', this.originalCss.top + 'px');
            if (this.appendTo) {
                this.setStyle('left', this.originalCss.left + 'px');
            }
            this.setClass(false);
            this.onUnStickyEvent.emit();
            this._onUnsetSticky();
        }
    }
    _onUnsetSticky() {
        setTimeout(() => { this.update(); }, 0);
    }
    onResize() { }
    ; // used by primeng directive to update table layout
    setStyle(key, value) {
        this.renderer.setStyle(this._stickyElement, key, value);
    }
    setClass(add) {
        if (add) {
            this.renderer.addClass(this._stickyElement, this.stickyClass);
        }
        else {
            this.renderer.removeClass(this._stickyElement, this.stickyClass);
        }
    }
};
StickyDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: StickyScrollService }
];
__decorate([
    Output(),
    __metadata("design:type", Object)
], StickyDirective.prototype, "onStickyEvent", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], StickyDirective.prototype, "onUnStickyEvent", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StickyDirective.prototype, "stickyClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], StickyDirective.prototype, "scrollOffset", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], StickyDirective.prototype, "appendTo", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StickyDirective.prototype, "stickyId", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StickyDirective.prototype, "sticksTo", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StickyDirective.prototype, "elementSelector", void 0);
StickyDirective = __decorate([
    Directive({
        selector: '[kSticky]'
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2, StickyScrollService])
], StickyDirective);

let StickyComponent = class StickyComponent {
    constructor(_stickyScrollService, _renderer) {
        this._stickyScrollService = _stickyScrollService;
        this._renderer = _renderer;
        this.wrapperHeight = 0;
        this.scrollOffset = 0;
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this._updateLayout();
        }, 0);
        this._stickyScrollService.resizeStatus$.pipe(cancelOnDestroy(this)).subscribe(event => {
            this._updateDimensions();
        });
    }
    _updateLayout() {
        if (this.content.nativeElement.children.length > 0) {
            this.wrapperHeight = this.content.nativeElement.children[0].clientHeight;
        }
        else {
            console.warn("Sticky component::could not access content.");
        }
    }
    updateLayout(manual = true) {
        setTimeout(() => {
            this._updateLayout();
            this._sticky.update();
        }, 0);
    }
    _updateDimensions() {
        this._renderer.setStyle(this.stickyDiv.nativeElement, 'width', `${this.content.nativeElement.offsetWidth}px`);
    }
    ngOnDestroy() {
    }
};
StickyComponent.ctorParameters = () => [
    { type: StickyScrollService },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], StickyComponent.prototype, "scrollOffset", void 0);
__decorate([
    Input('stickyClass'),
    __metadata("design:type", String)
], StickyComponent.prototype, "stickyClass", void 0);
__decorate([
    Input('container'),
    __metadata("design:type", Object)
], StickyComponent.prototype, "container", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StickyComponent.prototype, "stickyId", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], StickyComponent.prototype, "sticksTo", void 0);
__decorate([
    ViewChild('contentWrapper', { static: true }),
    __metadata("design:type", ElementRef)
], StickyComponent.prototype, "content", void 0);
__decorate([
    ViewChild('stickyDiv', { static: true }),
    __metadata("design:type", ElementRef)
], StickyComponent.prototype, "stickyDiv", void 0);
__decorate([
    ViewChild(StickyDirective, { static: true }),
    __metadata("design:type", StickyDirective)
], StickyComponent.prototype, "_sticky", void 0);
StickyComponent = __decorate([
    Component({
        selector: 'kSticky',
        template: "<div class=\"kStickyWrapper\" [style.height]=\"wrapperHeight + 'px'\" #contentWrapper>\n    <div #stickyDiv class=\"kSticky\" kSticky [scrollOffset]=\"scrollOffset\" [sticksTo]=\"sticksTo\" [stickyClass]=\"stickyClass\" [stickyId]=\"stickyId\" (onStickyEvent)=\"_updateDimensions()\" (onUnStickyEvent)=\"_updateDimensions()\">\n        <ng-content></ng-content>\n    </div>\n</div>\n",
        styles: [".kStickyWrapper{display:block}.kStickyWrapper .kSticky{z-index:501}"]
    }),
    __metadata("design:paramtypes", [StickyScrollService, Renderer2])
], StickyComponent);

var StickyModule_1;
let StickyModule = StickyModule_1 = class StickyModule {
    static forRoot() {
        return {
            ngModule: StickyModule_1,
            providers: [
                StickyScrollService
            ]
        };
    }
};
StickyModule = StickyModule_1 = __decorate([
    NgModule({
        imports: [
            KalturaCommonModule
        ],
        declarations: [
            StickyComponent,
            StickyDirective
        ],
        exports: [
            StickyComponent,
            StickyDirective
        ],
        providers: []
    })
], StickyModule);

let TagComponent = class TagComponent {
    constructor() {
        this.showRemove = true;
        this.onRemoved = new EventEmitter();
    }
    removeTag(tag) {
        this.onRemoved.emit(tag);
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], TagComponent.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TagComponent.prototype, "tooltip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TagComponent.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TagComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TagComponent.prototype, "showRemove", void 0);
__decorate([
    Input(),
    __metadata("design:type", TemplateRef)
], TagComponent.prototype, "template", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], TagComponent.prototype, "onRemoved", void 0);
TagComponent = __decorate([
    Component({
        selector: 'kTag',
        template: "<div class=\"kTag\" [class.kTagDisabled]=\"disabled\" *ngIf=\"label\" [ngSwitch]=\"!!template\">\n\t<div *ngSwitchCase=\"true\">\n\t\t<!-- CUSTOM TEMPLATE -->\n\t\t<ng-container *ngTemplateOutlet=\"template;context:{item: { label: label, tooltip: tooltip, showRemove: showRemove, data: data }}\"></ng-container>\n\t</div>\n    <div class=\"kTagContent\" title=\"{{tooltip}}\" *ngSwitchCase=\"false\">\n        <span class=\"kTagLabel\">{{label}}</span>\n        <i *ngIf=\"showRemove\" class=\"kTagRemove kIconclose_small\" (click)=\"!disabled && removeTag(data)\"></i>\n    </div>\n</div>\n",
        styles: [":host{display:table-cell}.kTag{display:table-cell;height:24px;background-color:#00a784;border-radius:3px;color:#fff;font-size:14px;font-weight:700;padding-left:8px;padding-right:2px}.kTag.kTagDisabled,.kTag.kTagDisabled:hover{background-color:transparent;color:#ccc;border:1px solid #ccc;border-radius:3px}.kTagContent{display:flex;align-items:center}.kTagLabel{flex:0 0 auto;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.kTagRemove{flex:0 0 auto;margin-top:2px;margin-left:8px;padding:5px;cursor:pointer;font-size:10px}.kTagRemove:hover{background-color:rgba(255,255,255,.3);border:0 solid rgba(255,255,255,.3);border-radius:3px}"]
    }),
    __metadata("design:paramtypes", [])
], TagComponent);

const $ = $NS;
let TagsComponent = class TagsComponent {
    constructor() {
        this.disabled = false;
        this.removableTags = true;
        this.showClear = true;
        this.clearAllLabel = "Clear All";
        this.onTagRemove = new EventEmitter();
        this.onRemoveAll = new EventEmitter();
        this.onTagsChange = new EventEmitter();
        this._showMore = false;
        this._scrollLeftEnabled = false;
        this._scrollRightEnabled = true;
    }
    onWindowResize() {
        this.checkShowMore();
    }
    ngOnChanges(changes) {
        if (changes['data']) {
            if (this.disabledField && Array.isArray(this.data)) {
                this.data.sort((a, b) => Number(b[this.disabledField] || 0) - Number(a[this.disabledField] || 0));
            }
            this.checkShowMore();
        }
    }
    ngAfterViewInit() {
        this.tagsListObserver = this.tagsList.changes.subscribe((comps) => {
            this.onTagsChange.emit({ tagsCount: (this.data ? this.data.length : 0) });
            this.checkShowMore();
        });
    }
    ngOnDestroy() {
        if (this.tagsListObserver) {
            this.tagsListObserver.unsubscribe();
            this.tagsListObserver = null;
        }
    }
    removeTag(tag) {
        this.onTagRemove.emit(tag);
    }
    clearAll() {
        this.onRemoveAll.emit();
    }
    checkShowMore() {
        // we use a cancelable interval to improve performances on window resize
        if (this.showMoreCheckIntervalID) {
            clearInterval(this.showMoreCheckIntervalID);
            this.showMoreCheckIntervalID = null;
        }
        this.showMoreCheckIntervalID = setTimeout(() => {
            if (this.data && this.data.length && this.scroller) {
                this._showMore = this.scroller.nativeElement.scrollWidth > (this.scroller.nativeElement.getBoundingClientRect().width + 1);
            }
            this.showMoreCheckIntervalID = null;
        }, 100);
    }
    scroll(direction) {
        const scrollPageWidth = this.scroller.nativeElement.getBoundingClientRect().width;
        const totalScroll = this.scroller.nativeElement.scrollWidth;
        if (direction === "right") {
            const targetScrollLeft = this.scroller.nativeElement.scrollLeft + scrollPageWidth;
            $(this.scroller.nativeElement).animate({ scrollLeft: targetScrollLeft }, 800, () => {
                this._scrollLeftEnabled = true;
                if ((this.scroller.nativeElement.scrollLeft + scrollPageWidth) >= (totalScroll - 1)) {
                    this._scrollRightEnabled = false;
                }
            });
        }
        else {
            const targetScrollLeft = this.scroller.nativeElement.scrollLeft - scrollPageWidth;
            $(this.scroller.nativeElement).animate({ scrollLeft: targetScrollLeft }, 800, () => {
                this._scrollRightEnabled = true;
                if (this.scroller.nativeElement.scrollLeft <= 1) {
                    this._scrollLeftEnabled = false;
                }
            });
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", Array)
], TagsComponent.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TagsComponent.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TagsComponent.prototype, "labelField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TagsComponent.prototype, "tooltipField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TagsComponent.prototype, "disabledField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TagsComponent.prototype, "removableTags", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TagsComponent.prototype, "showClear", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TagsComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TagsComponent.prototype, "clearAllLabel", void 0);
__decorate([
    ContentChildren(TemplateRef, { descendants: false }),
    __metadata("design:type", QueryList)
], TagsComponent.prototype, "templates", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], TagsComponent.prototype, "onTagRemove", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], TagsComponent.prototype, "onRemoveAll", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], TagsComponent.prototype, "onTagsChange", void 0);
__decorate([
    ViewChild('scroller', { static: false }),
    __metadata("design:type", ElementRef)
], TagsComponent.prototype, "scroller", void 0);
__decorate([
    ViewChildren(TagComponent),
    __metadata("design:type", QueryList)
], TagsComponent.prototype, "tagsList", void 0);
__decorate([
    HostListener("window:resize", []),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], TagsComponent.prototype, "onWindowResize", null);
TagsComponent = __decorate([
    Component({
        selector: 'kTags',
        template: "<div class=\"kTags\" *ngIf=\"data?.length\">\n    <span *ngIf=\"title\" class=\"kTagsTitle\">{{title}}</span>\n    <div #scroller class=\"kScroller\">\n        <div class=\"kTagsWrapper\">\n            <kTag *ngFor=\"let tag of data\"\n                  [data]=\"tag\"\n                  [template]=\"templates ? templates.first : undefined\"\n                  [showRemove]=\"removableTags\"\n                  [label]=\"labelField ? tag[labelField] : tag\"\n                  [tooltip]=\"tooltipField ? tag[tooltipField] : tag\"\n                  [disabled]=\"disabledField ? tag[disabledField] : false\"\n                  (onRemoved)=\"removeTag($event)\"></kTag>\n        </div>\n    </div>\n    <div class=\"kTagsMore\">\n        <div class=\"kScrollArrows\" [style.visibility]=\"_showMore ? 'visible' : 'hidden'\">\n            <i class=\"kIcondropdown_arrow_left kScrollArrow\" [class.disable]=\"!_scrollLeftEnabled\" (click)=\"scroll('left')\"></i>\n            <i class=\"kIcondropdown_arrow_right kScrollArrow\" [class.disable]=\"!_scrollRightEnabled\" (click)=\"scroll('right')\"></i>\n        </div>\n        <span *ngIf=\"showClear\" class=\"kTagsClear\" (click)=\"clearAll()\">{{clearAllLabel}}</span>\n    </div>\n\n</div>\n",
        styles: [":host{width:100%}.kTags{width:100%;height:40px;background-color:#fff;display:flex;flex-wrap:nowrap;-webkit-overflow-scrolling:touch;-ms-overflow-style:-ms-autohiding-scrollbar;align-items:center;border-top:1px solid #dadada;-ms-scroll-limit:0;overflow:hidden;-ms-overflow-style:none}.kTagsTitle{flex:0 0 auto;font-size:15px;color:#333;font-weight:700;margin-left:16px;margin-right:16px}.kTagsClear{margin-left:8px;margin-right:16px;flex-shrink:0;color:#333;font-size:15px;text-decoration:underline;cursor:pointer}.kTagsClear:hover{color:#00a784}.kMoreTagsBtn{flex-shrink:0}.kScroller{width:100%;overflow:hidden}.kTagsMore{align-items:center;display:flex;flex:0 0 auto;margin-left:8px}.kTagsWrapper{display:table;white-space:nowrap;border-collapse:separate;border-spacing:4px}.kScrollArrows{display:flex}.kScrollArrow{width:16px;margin-left:8px;margin-right:8px;cursor:pointer;color:#666}.kScrollArrow:hover{color:#333}.kScrollArrow.disable{cursor:auto;color:#ebebeb;pointer-events:none}.kScrollArrow.disable:hover{color:#ebebeb}"]
    }),
    __metadata("design:paramtypes", [])
], TagsComponent);

let TagsModule = class TagsModule {
};
TagsModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [
            TagsComponent,
            TagComponent
        ],
        exports: [
            TagsComponent,
            TagComponent
        ],
        providers: []
    })
], TagsModule);

// accepts http/https/ftp
const urlRegex = new RegExp("(ftp|https?):\\/\\/(www\\.)?[-a-zA-Z0-9^@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9^@:%_\\+.~#?&//=]*)", "i");
// accepts http/https
const urlHttpRegex = new RegExp("(https?):\\/\\/(www\\.)?[-a-zA-Z0-9^@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9^@:%_\\+.~#?&//=]*)", "i");
const ipRegex = new RegExp("^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$", "i");
/**
 * Provides a set of validators used by form controls.
 *
 * A validator is a function that processes a {@link FormControl} or collection of
 * controls and returns a map of errors. A null map means that validation has passed.
 *
 * ### Example
 *
 * ```typescript
 * var loginControl = new FormControl("", [Validators.ip, Validators.required])
 * ```
 *
 */
class KalturaValidators {
    /**
     * Validator that requires controls to have a value represented as IP (value not required).
     */
    static ip(control) {
        if (!control.value || !control.value.length)
            return null;
        return ipRegex.test(control.value) ? null : { 'ip': true };
    }
    /**
     * Validator that requires controls to have a value represented as URL (value not required).
     */
    static url(control) {
        if (!control.value || !control.value.length)
            return null;
        return urlRegex.test(control.value) ? null : { 'url': true };
    }
    /**
     * Validator that requires controls to have a value represented as URL (value not required).
     */
    static urlHttp(control) {
        if (!control.value || !control.value.length)
            return null;
        return urlHttpRegex.test(control.value) ? null : { 'url': true };
    }
    /**
     * Url validation
     */
    static isUrlValid(url) {
        return urlRegex.test(url);
    }
}

var OnDataSavingReasons;
(function (OnDataSavingReasons) {
    OnDataSavingReasons[OnDataSavingReasons["attachedWidgetBusy"] = 0] = "attachedWidgetBusy";
    OnDataSavingReasons[OnDataSavingReasons["validationErrors"] = 1] = "validationErrors";
    OnDataSavingReasons[OnDataSavingReasons["buildRequestFailure"] = 2] = "buildRequestFailure";
})(OnDataSavingReasons || (OnDataSavingReasons = {}));
class WidgetsManagerBase {
    constructor(logger) {
        this._widgets = [];
        this._widgetsState = new BehaviorSubject({});
        this._isNewData = false;
        this.widgetsState$ = this._widgetsState.asObservable();
        this._logger = logger ? logger.subLogger(`widgetsManager`) : new EmptyLogger();
    }
    get widgetsState() {
        return this._widgetsState.getValue();
    }
    get isNewData() {
        return this._isNewData;
    }
    _updateWidgetState(newWidgetState) {
        const currentWidgetsState = this._widgetsState.getValue();
        if (!newWidgetState || !newWidgetState.key) {
            this._logger.warn('[widgets manager] cannot update widget state, missing widget key');
        }
        else {
            this._logger.info(`[widgets manager] widget '${newWidgetState.key}': update widget state`, newWidgetState);
            currentWidgetsState[newWidgetState.key] = newWidgetState;
            this._widgetsState.next(currentWidgetsState);
        }
    }
    registerWidgets(widgets) {
        if (widgets) {
            widgets.forEach(widget => {
                const existingRegisteredWidget = this._widgets.find(registeredWidget => registeredWidget === widget || registeredWidget.key === widget.key);
                if (existingRegisteredWidget) {
                    throw new Error(`a widget with key '${widget.key}' is already registered (did you registered the same widget twice?)`);
                }
                else {
                    this._logger.info(`[widgets manager] widget '${widget.key}': registered to a form widgets manager`);
                    widget._setForm(this);
                    this._widgets.push(widget);
                }
            });
        }
    }
    notifyDataLoading(dataId) {
        this._logger.info(`[widgets manager] notify data loading. data identifier '${dataId}'`);
        this._widgets.filter(widget => widget.isActive).forEach(widget => {
            widget._reset();
        });
        this._widgets.forEach(widget => {
            widget._handleDataLoading(dataId);
        });
    }
    notifyDataLoaded(data, settings) {
        this._logger.info(`[widgets manager] notify data loaded.`);
        const errors = [];
        this._isNewData = settings.isNewData;
        this._logger.info(`[widgets manager] treat data as '${this._isNewData ? 'new' : 'existing'} data'.`);
        this._widgets.forEach(widget => {
            try {
                widget._handleDataLoaded(data);
                widget.activate();
            }
            catch (e) {
                errors.push(e);
            }
        });
        return { errors };
    }
    _widgetsOnDataSaving(newData, request, originalData) {
        const errors = [];
        const widgets = this._isNewData ? this._widgets : this._widgets.filter(widget => widget.isActive);
        widgets.forEach(widget => {
            try {
                this._logger.info(`[widgets manager] widget '${widget.key}': build save request content`);
                widget._handleDataSaving(newData, request, originalData);
            }
            catch (err) {
                this._logger.error(`[widgets manager] widget '${widget.key}': failed to prepare data for save. Save operation aborted.`, err); // keep error
                errors.push(err);
            }
        });
        return { errors };
    }
    notifyDataSaving(newData, request, originalData) {
        this._logger.info(`[widgets manager] notify data saving.`);
        const isAttachedWidgetBusy = !!this._widgets.find(widget => widget.isAttached && widget.isBusy);
        return Observable.of(isAttachedWidgetBusy ?
            {
                ready: false,
                reason: OnDataSavingReasons.attachedWidgetBusy
            } : { ready: true })
            .pipe(cancelOnDestroy(this))
            .flatMap(response => {
            if (response.ready) {
                return this._validateWidgets()
                    .catch((error, caught) => Observable.of({ isValid: false }))
                    .map(response => response.isValid ? { ready: true } : {
                    ready: false,
                    reason: OnDataSavingReasons.validationErrors
                });
            }
            else {
                return Observable.of(response);
            }
        })
            .map(response => {
            if (response.ready) {
                const saveContent = this._widgetsOnDataSaving(newData, request, originalData);
                if (saveContent.errors.length === 0) {
                    return { ready: true, reason: null };
                }
                else {
                    return {
                        ready: false,
                        reason: OnDataSavingReasons.buildRequestFailure,
                        errors: saveContent.errors
                    };
                }
            }
            else {
                return response;
            }
        });
    }
    _validateWidgets() {
        const widgets = this._isNewData ? this._widgets : this._widgets.filter(widget => widget.isActive);
        const widgetsResults = widgets.map(widget => {
            return widget._validate()
                .pipe(cancelOnDestroy(this))
                .catch((err, caught) => Observable.of({ isValid: false }));
        });
        if (widgetsResults.length) {
            return Observable.forkJoin(...widgetsResults).map(responses => {
                return responses.find(response => !response.isValid) || { isValid: true };
            });
        }
        else {
            return Observable.of({ isValid: true });
        }
    }
    ngOnDestroy() {
        this._widgets.forEach(widget => {
            widget.destory();
        });
        this._logger.warn('[widgets manager] form widgets manager ngOnDestroy');
        this._widgetsState.complete();
    }
}

// DEVELOPER NOTE: Don't implement ngOnDestroy - the inheritor will probably override this without calling super()
class WidgetBase {
    constructor(_key, logger) {
        this._key = _key;
        // DEVELOPER NOTE: this class cannot use 'cancelOnDestroy' operation
        // because it must assume the inheriter will override it
        this._activateSubscription = null;
        this._dataSource = new ReplaySubject(1);
        this.data$ = this._dataSource.asObservable();
        this._widgetState = { key: this.key, isValid: true, isDirty: false, isAttached: false, isBusy: false, isActive: false, wasActivated: false };
        this._widgetReset = new Subject();
        this.widgetReset$ = this._widgetReset.asObservable();
        if (!_key) {
            throw new Error(`Form widget key is required when constructing widget of type '${typeof this}`);
        }
        this._logger = logger ? logger.subLogger(`widgets.${_key}`) : new EmptyLogger();
    }
    get data() {
        return this._data;
    }
    onDataSaving(newData, request, originalData) {
    }
    get wasActivated() {
        return this._widgetState.wasActivated;
    }
    get isValid() {
        return this._widgetState.isValid;
    }
    get isDirty() {
        return this._widgetState.isDirty;
    }
    get isActive() {
        return this._widgetState.isActive;
    }
    get isAttached() {
        return this._widgetState.isAttached;
    }
    get isBusy() {
        return this._widgetState.isBusy;
    }
    get key() {
        return this._key;
    }
    get isNewData() {
        return this.form.isNewData;
    }
    onValidate(wasActivated) {
        return Observable.of({ isValid: true });
    }
    updateState(stateUpdate) {
        this._updateState(stateUpdate);
    }
    _updateState(stateUpdate) {
        this._verifyRegistered();
        const stateHasChanges = Object.keys(stateUpdate).reduce((result, propertyName) => result || this._widgetState[propertyName] !== stateUpdate[propertyName], false);
        if (stateHasChanges) {
            Object.assign(this._widgetState, stateUpdate);
            if (this.form) {
                const newWidgetState = Object.assign({}, this._widgetState);
                this.form._updateWidgetState(newWidgetState);
            }
        }
    }
    onDataLoaded(data) {
    }
    onDataLoading(dataId) {
    }
    onActivate(firstTimeActivating) {
    }
    _setForm(manager) {
        this.form = manager;
    }
    _handleDataLoading(dataId) {
        this._verifyRegistered();
        this._setData(null);
        this.onDataLoading(dataId);
    }
    _setData(data) {
        this._data = data;
        this._dataSource.next(data);
    }
    _handleDataLoaded(data) {
        this._verifyRegistered();
        this._setData(data);
        this.onDataLoaded(data);
    }
    _validate() {
        this._verifyRegistered();
        return this.onValidate(this.wasActivated)
            .do(response => {
            const updateState = (response.isValid !== this._widgetState.isValid);
            if (updateState) {
                this._logger.info(`[widget] widget '${this.key}': widget 'isValid' state doesn't match result of 'onValidate'. updating status to '${response.isValid ? 'valid' : 'invalid'}'`);
                this.updateState({ isValid: response.isValid });
            }
        });
    }
    _handleDataSaving(newData, request, originalData) {
        this._verifyRegistered();
        this.onDataSaving(newData, request, originalData);
    }
    _reset() {
        this._verifyRegistered();
        this._logger.info(`[widget] widget '${this.key}': reset widget`);
        if (this._activateSubscription) {
            this._activateSubscription.unsubscribe();
            this._activateSubscription = null;
        }
        this._widgetReset.next('');
        this._updateState({ isValid: true, isDirty: false, isActive: false, isBusy: false });
        this.onReset();
    }
    _verifyRegistered() {
        if (!this.form) {
            this._logger.error(`[widget] widget '${this.key}': cannot perform action, widget is not registered to a manager (did you forgot to register it in the main route component?)`);
            throw new Error(`[widget] cannot perform action. widget with key \''${this.key}'\' is not registered to a manager`);
        }
    }
    activate() {
        this._verifyRegistered();
        if (this.data && this.isAttached && !this.isActive) {
            this._reset();
            const previousStatus = {
                wasActivated: this.wasActivated
            };
            this._logger.info(`[widget] widget '${this.key}': activating widget (first time = ${!previousStatus.wasActivated})`);
            const activate$ = this.onActivate(!this.wasActivated);
            this._updateState({ isActive: true, wasActivated: true });
            if (activate$ instanceof Observable) {
                this._logger.info(`[widget] widget '${this.key}': widget requested for async activation operation. executing async operation.`);
                this._activateSubscription = activate$
                    .catch((error, caught) => Observable.of({ failed: true, error }))
                    .subscribe(response => {
                    if (response && response.failed) {
                        this._logger.info(`[widget] widget '${this.key}': async widget activation failed. revert state to ${JSON.stringify(previousStatus)})`);
                        this._updateState({ isActive: false, wasActivated: previousStatus.wasActivated });
                    }
                    else {
                        this._logger.info(`[widget] widget '${this.key}': async widget activation completed`);
                    }
                }, () => {
                    this._activateSubscription = null;
                }, () => {
                    this._activateSubscription = null;
                });
            }
        }
    }
    attachForm() {
        this._verifyRegistered();
        if (this.isAttached) {
            this._logger.warn(`[widget] widget with key '${this.key}' is already attached (did you attached two components to the same widget? did you forgot to detach the widget upon ngOnDestroy?)`);
        }
        else {
            this._logger.info(`[widget] widget '${this.key}': attaching widget`);
            this._updateState({ isAttached: true });
            this.activate();
        }
    }
    detachForm() {
        this._verifyRegistered();
        if (!this.isAttached) {
            this._logger.warn(`[widget] widget with key '${this.key}' is already detached (did you attached two components to the same widget? did you forgot to attach the widget upon ngOnInit?)`);
        }
        else {
            this._logger.info(`[widget] widget '${this.key}': detaching widget`);
            this._updateState({ isAttached: false });
        }
    }
    destory() {
        this._reset();
        this._widgetReset.complete();
    }
}

let FileDialogComponent = class FileDialogComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.filter = "";
        this.allowMultiple = false;
        this.onFileSelected = new EventEmitter();
    }
    open(event) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        this.elementRef.nativeElement.firstElementChild.value = "";
        this.elementRef.nativeElement.firstElementChild.click();
    }
    _fileInputChange(event) {
        if (event.currentTarget.files && event.currentTarget.files.length) {
            this.onFileSelected.emit(event.currentTarget.files);
        }
    }
    ngOnInit() {
    }
};
FileDialogComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], FileDialogComponent.prototype, "filter", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], FileDialogComponent.prototype, "allowMultiple", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], FileDialogComponent.prototype, "onFileSelected", void 0);
FileDialogComponent = __decorate([
    Component({
        selector: 'kFileDialog',
        template: "<input tabindex=\"-1\" [attr.multiple]=\"allowMultiple ? true : null\" type=\"file\" accept=\"{{filter}}\" (change)=\"_fileInputChange($event)\"/>\n",
        styles: ["input{position:fixed;left:-1000px;top:-1000px}"]
    }),
    __metadata("design:paramtypes", [ElementRef])
], FileDialogComponent);

const moment = momentNS;
let DatePipe = class DatePipe {
    constructor() { }
    transform(date, format) {
        if (date) {
            if (!format) {
                format = "dateAndTime";
            }
            switch (format) {
                case 'dateOnly':
                    format = 'MM/DD/YY';
                    break;
                case 'timeOnly':
                    format = 'HH:mm';
                    break;
                case 'dateAndTime':
                    format = "MM/DD/YY HH:mm";
                    break;
                case 'longDateOnly':
                    format = "MMMM D, YYYY";
                    break;
                default:
                    break;
            }
            return moment(date).format(format);
        }
        else {
            return '';
        }
    }
};
DatePipe = __decorate([
    Pipe({
        name: 'kDate'
    }),
    __metadata("design:paramtypes", [])
], DatePipe);

/*
 * Convert bytes into largest possible unit.
 * Takes an precision argument that defaults to 2.
 * Usage:
 *   bytes | fileSize:precision
 * Example:
 *   {{ 1024 |  fileSize}}
 *   formats to: 1 KB
 */
let FileSizePipe = class FileSizePipe {
    constructor() {
        this.units = [
            'bytes',
            'KB',
            'MB',
            'GB',
            'TB',
            'PB'
        ];
    }
    transform(bytes = 0, precision = 2) {
        if (isNaN(parseFloat(String(bytes))) || !isFinite(bytes))
            return 'N/A';
        let unit = 0;
        while (bytes >= 1024) {
            bytes /= 1024;
            unit++;
        }
        return bytes.toFixed(+precision) + ' ' + this.units[unit];
    }
};
FileSizePipe = __decorate([
    Pipe({ name: 'kFileSize' })
], FileSizePipe);

let AutofocusDirective = class AutofocusDirective {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this._autofocus = true;
    }
    ngAfterViewInit() {
        if (this._autofocus) {
            setTimeout(() => {
                this.renderer.selectRootElement(this.el.nativeElement).focus();
            });
        }
    }
    set inputAutofocus(allowed) {
        this._autofocus = allowed;
    }
};
AutofocusDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], AutofocusDirective.prototype, "inputAutofocus", null);
AutofocusDirective = __decorate([
    Directive({
        selector: '[kAutofocus]'
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], AutofocusDirective);

var BrowserNames;
(function (BrowserNames) {
    BrowserNames[BrowserNames["IE11"] = 0] = "IE11";
    BrowserNames[BrowserNames["other"] = 1] = "other";
})(BrowserNames || (BrowserNames = {}));
class KalturaBrowserUtils {
    static detectBrowser() {
        if (!!window['MSInputMethodContext'] && !!document['documentMode']) {
            return BrowserNames.IE11;
        }
        else {
            return BrowserNames.other;
        }
    }
}

let SafePipe = class SafePipe {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    transform(url) {
        return this.sanitizer.bypassSecurityTrustResourceUrl(url);
    }
};
SafePipe.ctorParameters = () => [
    { type: DomSanitizer }
];
SafePipe = __decorate([
    Pipe({ name: 'safe' }),
    __metadata("design:paramtypes", [DomSanitizer])
], SafePipe);

let TimePipe = class TimePipe {
    transform(value) {
        if (typeof value === "string") {
            return value;
        }
        else {
            let hours = Math.floor(Math.round(value) / 3600);
            let minutes = Math.floor((Math.round(value) / 60) % 60);
            let seconds = Math.round(value) % 60;
            let hoursStr = hours === 0 ? '' : hours.toString() + ":";
            let minutesStr = minutes === 0 && hours === 0 ? '00' : minutes < 10 ? '0' + minutes.toString() : minutes.toString();
            let secondsStr = seconds < 10 ? '0' + seconds.toString() : seconds.toString();
            return hoursStr + minutesStr + ":" + secondsStr;
        }
    }
};
TimePipe = __decorate([
    Pipe({ name: 'kTime' })
], TimePipe);

let LineBreakPipe = class LineBreakPipe {
    constructor() { }
    transform(str) {
        if (str.split("\r").length > 0 && str.split("\r\n").length < str.split("\r").length) {
            str = str.split("\r").join("\r\n");
        }
        return str;
    }
};
LineBreakPipe = __decorate([
    Pipe({
        name: 'kLineBreak'
    }),
    __metadata("design:paramtypes", [])
], LineBreakPipe);

let ScrollToTopContainerComponent = class ScrollToTopContainerComponent {
    constructor(_el) {
        this._el = _el;
    }
    scrollToTop() {
        this._el.nativeElement.scrollTop = 0;
    }
};
ScrollToTopContainerComponent.ctorParameters = () => [
    { type: ElementRef }
];
ScrollToTopContainerComponent = __decorate([
    Component({
        selector: 'kScrollToTopContainer',
        template: '<ng-content></ng-content>',
        styles: [':host { display: block }']
    }),
    __metadata("design:paramtypes", [ElementRef])
], ScrollToTopContainerComponent);

let KalturaUIModule = class KalturaUIModule {
};
KalturaUIModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [
            SafePipe,
            TimePipe,
            FileDialogComponent,
            KalturaPlayerComponent,
            DatePipe,
            FileSizePipe,
            LineBreakPipe,
            AutofocusDirective,
            ScrollToTopContainerComponent,
        ],
        exports: [
            TimePipe,
            SafePipe,
            FileDialogComponent,
            KalturaPlayerComponent,
            DatePipe,
            FileSizePipe,
            LineBreakPipe,
            AutofocusDirective,
            ScrollToTopContainerComponent
        ],
        providers: []
    })
], KalturaUIModule);

var InputRangeComponent_1;
let InputRangeComponent = InputRangeComponent_1 = class InputRangeComponent {
    constructor() {
        this.pointOvered = [];
        this.onChange = (value) => { };
        this.onTouched = () => { };
    }
    ngOnInit() {
        this.selectedOptionIndex = this.options.findIndex(option => option.isSelected);
        this.selectedOptionIndex = this.selectedOptionIndex == -1 ? 0 : this.selectedOptionIndex;
        this.selectedText = this.options[this.selectedOptionIndex].label;
    }
    getProgressBarStyle() {
        return 100 / (this.options.length - 1) * (this.selectedOptionIndex >= 0 ? this.selectedOptionIndex : 0);
    }
    pointSelected(index) {
        if (this.selectedOptionIndex > 0) {
            this.options[this.selectedOptionIndex].isSelected = false;
        }
        this.options[index].isSelected = true;
        this.selectedText = this.options[index].label;
        this.selectedOptionIndex = index;
        this.onTouched();
        this.onChange(this.options[index].value);
    }
    //From ControlValueAccessor interface
    writeValue(value) {
        const valueOptionIndex = this.options.findIndex(option => option.value == value);
        if (valueOptionIndex !== -1) {
            this.pointSelected(valueOptionIndex);
        }
    }
    //From ControlValueAccessor interface
    registerOnChange(fn) {
        this.onChange = fn;
    }
    //From ControlValueAccessor interface
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
};
__decorate([
    Input(),
    __metadata("design:type", Array)
], InputRangeComponent.prototype, "options", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], InputRangeComponent.prototype, "width", void 0);
InputRangeComponent = InputRangeComponent_1 = __decorate([
    Component({
        selector: 'kInputRange',
        template: "<div class=\"kRangeContainer\">\n  <div [style.width]=\"width\">\n    <div class=\"kRangeInput kRangeInputBlock\">\n      <div class=\"kBbar\">\n        <div class=\"kBarProgress\"\n             [style.width]=\"getProgressBarStyle() + '%'\"></div>\n        <div class=\"kBarPoints\">\n          <div class=\"kBarPointCol\" (mouseout)=\"pointOvered[i]=false\" (mouseover)=\"pointOvered[i]=true\" [style.width]=\"100 / (options.length-1) + '%'\"\n               *ngFor=\"let option of options; index as i\">\n            <div class=\"kPoint\"\n                 [ngClass]=\"{\n                 'kSelected': (pointOvered.length > 0 && pointOvered[i]) || i == selectedOptionIndex,\n                 'kBgPrimary':  i <= selectedOptionIndex\n               }\"></div>\n            <div class=\"kPointClickArea\"\n                 (click) = \"pointSelected(i)\"\n                 [kTooltip] = \"option.tooltip\"></div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n  <span class=\"kSelectedLabel\">{{selectedText}}</span>\n</div>\n",
        providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: InputRangeComponent_1,
                multi: true
            }
        ],
        styles: [".kRangeContainer{display:flex}.kRangeContainer .kRangeInput{display:inline-block;padding-top:10px;padding-bottom:50px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.kRangeContainer .kRangeInput.kRangeInputBlock{display:block;width:100%}.kRangeContainer .kRangeInput .kBbar{height:4px;width:100%;background-color:#ccc;position:relative}.kRangeContainer .kRangeInput .kBbar .kBarProgress{background-color:#00a784;height:100%}.kRangeContainer .kRangeInput .kBbar .kBarPoints{position:absolute;left:0;top:-8px;width:100%}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol{float:left;position:relative;height:20px}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol:last-child{width:0%!important}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol .kPointClickArea{position:absolute;width:45px;margin-top:-10px;height:40px;transform:translateX(-50%);cursor:pointer}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol .kPoint{width:9px;height:9px;margin-top:1px;border-radius:50%;background-color:#ccc;position:absolute;transform:translateX(-50%);cursor:pointer;border:4px solid #fff}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol .kPoint.kSelected{width:16px;height:16px;margin-top:-3px;border-radius:50%}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol .kPoint.kBgPrimary{background-color:#00a784}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol .kPoint.kBgPrimary.kSelected{border:none!important;margin-top:2px!important}.kRangeContainer .kRangeInput .kBbar .kBarPoints .kBarPointCol span{position:absolute;transform:translateX(-50%);bottom:-36px;white-space:nowrap}.kRangeContainer .kSelectedLabel{padding-left:30px;padding-top:3px;font-size:15px}"]
    }),
    __metadata("design:paramtypes", [])
], InputRangeComponent);

let InputRangeModule = class InputRangeModule {
};
InputRangeModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            TooltipModule
        ],
        declarations: [
            InputRangeComponent
        ],
        exports: [
            InputRangeComponent
        ],
        providers: []
    })
], InputRangeModule);

/*
 * Public API Surface of kaltura-ui
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AreaBlockerComponent, AreaBlockerMessage, AreaBlockerModule, AutofocusDirective, BrowserNames, DatePickerControl, DatePipe, DetailInfoComponent, DetailsBarComponent, DetailsBarModule, DynamicDropdownControl, DynamicFormControlBase, DynamicFormItem, DynamicFormModule, DynamicFormService, DynamicSectionControl, FileDialogComponent, FileSizePipe, InputHelperComponent, InputHelperModule, InputRangeComponent, InputRangeModule, KTooltipDirective, KalturaBrowserUtils, KalturaPlayerComponent, KalturaUIModule, KalturaValidators, LineBreakPipe, ListControl, NumberControl, OnDataSavingReasons, PopupWidgetComponent, PopupWidgetModule, PopupWidgetStates, SafePipe, ScrollToTopContainerComponent, StickyComponent, StickyDirective, StickyModule, StickyScrollService, SwitchControl, TagComponent, TagsComponent, TagsModule, TextAreaControl, TextboxControl, TimePipe, TooltipModule, WidgetBase, WidgetsManagerBase, ipRegex, urlHttpRegex, urlRegex };
//# sourceMappingURL=kaltura-ng-kaltura-ui.js.map
